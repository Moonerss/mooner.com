<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>WGCNA教程</title>
      <link href="2020/08/15/wgcna/"/>
      <url>2020/08/15/wgcna/</url>
      
        <content type="html"><![CDATA[<p>WGCNA的基本原理和操作  </p><a id="more"></a>  <h1 id="WGCNA-分析"><a href="#WGCNA-分析" class="headerlink" title="WGCNA 分析"></a>WGCNA 分析</h1><h2 id="WGCNA基本概念"><a href="#WGCNA基本概念" class="headerlink" title="WGCNA基本概念"></a>WGCNA基本概念</h2><p>加权基因共表达网络分析 (WGCNA, Weighted correlation network analysis)是用来描述不同样品之间基因关联模式的系统生物学方法，可以用来鉴定高度<strong>协同变化</strong>的基因集。并根据基因集的内连性和基因集与表型之间的关联鉴定候补生物标记基因或治疗靶点。  </p><p>相比于只关注差异表达的基因，WGCNA利用数千或近万个变化最大的基因或全部基因的信息识别感兴趣的基因集，并与表型进行显著性关联分析。一是充分利用了信息，二是把数千个基因与表型的关联转换为数个基因集与表型的关联，免去了多重假设检验校正的问题。  </p><h2 id="WGCNA常见术语"><a href="#WGCNA常见术语" class="headerlink" title="WGCNA常见术语"></a>WGCNA常见术语</h2><ul><li>共表达网络（Co-expression network）：定义为加权基因网络。点代表基因，边代表基因表达相关性。加权是指对<strong>相关性值进行冥次运算</strong>。 (冥次的值也就是<strong>软阈值</strong> (<code>power</code>, <code>/post/2020-08-15-wgcna_fileskSoftThreshold</code>这个函数所做的就是确定合适的<code>power</code>))。无向网络的边属性计算方式为 <code>abs(cor(genex, geney)) ^ power</code>；有向网络的边属性计算方式为<code>(1+cor(genex, geney)/2) ^ power</code>; <code>sign hybrid</code>的边属性计算方式为<code>cor(genex, geney)^power if cor&gt;0 else 0</code>。这种处理方式强化了强相关，弱化了弱相关或负相关，使得相关性数值更符合<code>无标度网络</code>特征，更具有生物意义。如果没有合适的<strong>power</strong>，一般是由于部分样品与其它样品因为某种原因差别太大导致的，可根据具体问题移除部分样品或查看后面的<code>经验值</code>。  </li><li>模块（Module）：高度內连的基因集。在无向网络中，模块内是高度<strong>相关</strong>的基因。在有向网络中，模块内是高度<strong>正相关</strong>的基因。把基因聚类成模块后，可以对每个模块进行三个层次的分析：<ol><li>功能富集分析查看其功能特征是否与研究目的相符；</li><li>模块与性状进行关联分析，找出与关注性状相关度最高的模块；</li><li>模块与样本进行关联分析，找到样品特异高表达的模块。</li></ol></li><li>连接度（Connectivity）：类似于网络中 “度”(degree)的概念。每个基因的连接度是与其他网络基因的连接度。 在共表达网络中，连接度衡量的是一个基因与其他的网络基因有多相关。 </li><li>模块内连接度（Intramodular connectivity）: 模块内连接度衡量的是给定基因相对于特定模块的基因是如何连接或共同表达的。模内连接性可以解释为模块成员关系的度量。  </li><li>Module eigengene E: 给定模型的第一主成分，代表<strong>整个模型的基因表达谱</strong>。  </li><li>Module membership: 给定基因表达谱与给定模型的eigengene的相关性。  </li><li>Hub gene: 关键基因 (连接度最多或连接多个模块的基因)。  </li><li>Adjacency matrix ：基因和基因之间的加权相关性值构成的矩阵。  </li><li>TOM (Topological overlap matrix)：把邻接矩阵转换为拓扑重叠矩阵，以降低噪音和假相关，获得的新距离矩阵，这个信息可拿来构建网络或绘制TOM图。  </li><li>Gene signifcance GS：基因表达模式与某样本特质之间的相关，一般相关值越大，表示该基因越重要，有时候也用<code>-log（p）</code>来量化  </li><li>Module signifcance：该模块中所有基因相关绝对值的均值。当基因相关是基于基因表达模式与样本特质之间的相关值时，该测量与模块特征基因和样本特质之间存在高相关。  </li></ul><h2 id="基本分析流程"><a href="#基本分析流程" class="headerlink" title="基本分析流程"></a>基本分析流程</h2><p><img src="/images/wgcna/wgcna.png" alt="WGCNA">  </p><ol><li>构建基因共表达网络：使用加权的表达相关性。基本目的是充分利用基因间的交互模式；采用相关系数作为共表达的测量。  </li><li>识别基因集：基于加权相关性，进行层级聚类分析，并根据设定标准切分聚类结果，获得不同的基因模块，用聚类树的分枝和不同颜色表示。可以采用层次聚类（hierarchical clustering）或动态树切分（dynamic tree cut）实现。  </li><li>将模块与外部信息关联。其中外部信息包括基于阵列的临床数据（clinical data），多态性数据（SNPs）和蛋白组数据（proteomics）；基因信息包括ontology和功能富集（functional enrichment）。基本目的是发现具有生物学意义的模块。  </li><li>研究模型之间的关系，从系统层面查看不同模型的互作网络。基本目的是生物数据降维，并提供系统水平的视角（system-level view）；采用eigengene网络实现。  </li><li>最后发现感兴趣模块的关键驱动子（key drivers）。基本目的是实验验证并明确生物标记（biomarker）；采用的手段可以是模块内连接（intramodular connectivity）以及因果检验（causality testing）。  </li></ol><h2 id="WGCNA包实战"><a href="#WGCNA包实战" class="headerlink" title="WGCNA包实战"></a>WGCNA包实战</h2><p>R包<code>WGCNA</code>是用于计算各种加权关联分析的功能集合，可用于网络构建，基因筛选，基因簇鉴定，拓扑特征计算，数据模拟和可视化等。 </p><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ol><li>WGCNA本质是基于相关系数的网络分析方法，适用于多样品数据模式，一般要求样本数多于<strong>15</strong>个。样本数多于<strong>20</strong>时效果更好，样本越多，结果越稳定。  </li><li>基因表达矩阵: 常规表达矩阵即可，即基因在行，样品在列，进入分析前做一个转置。RPKM、FPKM或其它标准化方法影响不大。  </li><li>安装WGCNA   </li></ol><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">library</span>(WGCNA)</span><br><span class="line">Loading required package: dynamicTreeCut</span><br><span class="line">Loading required package: fastcluster</span><br><span class="line"></span><br><span class="line">Attaching package: ‘fastcluster’</span><br><span class="line"></span><br><span class="line">The following object is masked from ‘package:stats’:</span><br><span class="line"></span><br><span class="line">    hclust</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Attaching package: ‘WGCNA’</span><br><span class="line"></span><br><span class="line">The following object is masked from ‘package:stats’:</span><br><span class="line"></span><br><span class="line">    cor</span><br><span class="line"></span><br><span class="line">options(stringsAsFactors = <span class="literal">FALSE</span>)</span><br><span class="line"><span class="comment"># 开启多线程</span></span><br><span class="line">enableWGCNAThreads()</span><br><span class="line">Allowing parallel execution with up to <span class="number">7</span> working processes.</span><br><span class="line"></span><br><span class="line">load(<span class="string">&quot;./data.RData&quot;</span>)</span><br><span class="line">head(datTraits)  </span><br><span class="line">                  gsm cellline       subtype</span><br><span class="line">GSM1172844 GSM1172844    184A1 Non-malignant</span><br><span class="line">GSM1172845 GSM1172845    184B5 Non-malignant</span><br><span class="line">GSM1172846 GSM1172846    21MT1         Basal</span><br><span class="line">GSM1172847 GSM1172847    21MT2         Basal</span><br><span class="line">GSM1172848 GSM1172848     21NT         Basal</span><br><span class="line">GSM1172849 GSM1172849     21PT         Basal</span><br><span class="line">fpkm[<span class="number">1</span>:<span class="number">4</span>,<span class="number">1</span>:<span class="number">4</span>]  </span><br><span class="line">                GSM1172844 GSM1172845 GSM1172846  GSM1172847</span><br><span class="line">ENSG00000000003   <span class="number">95.21255</span>   <span class="number">95.69868</span>   <span class="number">19.99467</span>  <span class="number">65.6863763</span></span><br><span class="line">ENSG00000000005    <span class="number">0.00000</span>    <span class="number">0.00000</span>    <span class="number">0.00000</span>   <span class="number">0.1492021</span></span><br><span class="line">ENSG00000000419  <span class="number">453.20831</span>  <span class="number">243.64804</span>  <span class="number">142.05818</span> <span class="number">200.4131493</span></span><br><span class="line">ENSG00000000457   <span class="number">18.10439</span>   <span class="number">26.56661</span>   <span class="number">16.12776</span>  <span class="number">12.0873135</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 选取前5000高变异的基因计算WGCNA</span></span><br><span class="line">datExpr &lt;- t(fpkm[order(apply(fpkm,<span class="number">1</span>,mad), decreasing = <span class="literal">T</span>)[<span class="number">1</span>:<span class="number">5000</span>],])</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="1-确定最佳beta值"><a href="#1-确定最佳beta值" class="headerlink" title="1. 确定最佳beta值"></a>1. 确定最佳beta值</h3><blockquote><p>在这里选取的软阈值是为了构建最有效的无尺度网络。</p></blockquote><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">powers = c(c(<span class="number">1</span>:<span class="number">10</span>), seq(from = <span class="number">12</span>, to=<span class="number">20</span>, by=<span class="number">2</span>))</span><br><span class="line"><span class="comment">## 批量计算多个power值的R方</span></span><br><span class="line">sft = pickSoftThreshold(datExpr, powerVector = powers, RsquaredCut = <span class="number">0.85</span>, verbose = <span class="number">5</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">pickSoftThreshold: will use block size <span class="number">5000.</span></span><br><span class="line"> pickSoftThreshold: calculating connectivity <span class="keyword">for</span> given powers...</span><br><span class="line">   ..working on genes <span class="number">1</span> through <span class="number">5000</span> of <span class="number">5000</span></span><br><span class="line">   Power SFT.R.sq  slope truncated.R.sq  mean.k. median.k.  max.k.</span><br><span class="line"><span class="number">1</span>      <span class="number">1</span>   <span class="number">0.0944</span> -<span class="number">0.904</span>          <span class="number">0.885</span> <span class="number">1040.000</span>  <span class="number">1.02e+03</span> <span class="number">1810.00</span></span><br><span class="line"><span class="number">2</span>      <span class="number">2</span>   <span class="number">0.4910</span> -<span class="number">1.580</span>          <span class="number">0.952</span>  <span class="number">328.000</span>  <span class="number">3.03e+02</span>  <span class="number">866.00</span></span><br><span class="line"><span class="number">3</span>      <span class="number">3</span>   <span class="number">0.7030</span> -<span class="number">1.860</span>          <span class="number">0.983</span>  <span class="number">128.000</span>  <span class="number">1.08e+02</span>  <span class="number">474.00</span></span><br><span class="line"><span class="number">4</span>      <span class="number">4</span>   <span class="number">0.7920</span> -<span class="number">2.000</span>          <span class="number">0.991</span>   <span class="number">57.300</span>  <span class="number">4.38e+01</span>  <span class="number">283.00</span></span><br><span class="line"><span class="number">5</span>      <span class="number">5</span>   <span class="number">0.8490</span> -<span class="number">2.060</span>          <span class="number">0.996</span>   <span class="number">28.400</span>  <span class="number">1.95e+01</span>  <span class="number">179.00</span></span><br><span class="line"><span class="number">6</span>      <span class="number">6</span>   <span class="number">0.8810</span> -<span class="number">2.090</span>          <span class="number">0.991</span>   <span class="number">15.200</span>  <span class="number">9.45e+00</span>  <span class="number">118.00</span></span><br><span class="line"><span class="number">7</span>      <span class="number">7</span>   <span class="number">0.9040</span> -<span class="number">2.070</span>          <span class="number">0.990</span>    <span class="number">8.640</span>  <span class="number">4.89e+00</span>   <span class="number">80.60</span></span><br><span class="line"><span class="number">8</span>      <span class="number">8</span>   <span class="number">0.9220</span> -<span class="number">2.040</span>          <span class="number">0.994</span>    <span class="number">5.170</span>  <span class="number">2.67e+00</span>   <span class="number">56.40</span></span><br><span class="line"><span class="number">9</span>      <span class="number">9</span>   <span class="number">0.9330</span> -<span class="number">2.030</span>          <span class="number">0.995</span>    <span class="number">3.240</span>  <span class="number">1.54e+00</span>   <span class="number">40.50</span></span><br><span class="line"><span class="number">10</span>    <span class="number">10</span>   <span class="number">0.9350</span> -<span class="number">2.020</span>          <span class="number">0.989</span>    <span class="number">2.100</span>  <span class="number">9.29e-01</span>   <span class="number">30.00</span></span><br><span class="line"><span class="number">11</span>    <span class="number">12</span>   <span class="number">0.9250</span> -<span class="number">2.030</span>          <span class="number">0.977</span>    <span class="number">0.971</span>  <span class="number">3.63e-01</span>   <span class="number">17.30</span></span><br><span class="line"><span class="number">12</span>    <span class="number">14</span>   <span class="number">0.9210</span> -<span class="number">2.020</span>          <span class="number">0.982</span>    <span class="number">0.496</span>  <span class="number">1.56e-01</span>   <span class="number">10.50</span></span><br><span class="line"><span class="number">13</span>    <span class="number">16</span>   <span class="number">0.9250</span> -<span class="number">1.970</span>          <span class="number">0.992</span>    <span class="number">0.275</span>  <span class="number">7.04e-02</span>    <span class="number">6.61</span></span><br><span class="line"><span class="number">14</span>    <span class="number">18</span>   <span class="number">0.8940</span> -<span class="number">1.960</span>          <span class="number">0.973</span>    <span class="number">0.163</span>  <span class="number">3.31e-02</span>    <span class="number">4.31</span></span><br><span class="line"><span class="number">15</span>    <span class="number">20</span>   <span class="number">0.9220</span> -<span class="number">1.820</span>          <span class="number">0.986</span>    <span class="number">0.102</span>  <span class="number">1.63e-02</span>    <span class="number">2.89</span></span><br><span class="line">power = sft$powerEstimate</span><br><span class="line">power</span><br><span class="line">[<span class="number">1</span>] <span class="number">6</span></span><br></pre></td></tr></table></figure><blockquote><p>由以上结果可以看出在power = 6时首次达到R方的cut阈值0.85，因此选取6作为合适的power值</p></blockquote><p>通过绘图更加直观的观察阈值的选取：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">par(mfrow = c(<span class="number">1</span>,<span class="number">2</span>));</span><br><span class="line">cex1 = <span class="number">0.9</span>;</span><br><span class="line"><span class="comment"># Scale-free topology fit index as a function of the soft-thresholding power</span></span><br><span class="line">plot(sft$fitIndices[,<span class="number">1</span>], -sign(sft$fitIndices[,<span class="number">3</span>])*sft$fitIndices[,<span class="number">2</span>],</span><br><span class="line">      xlab=<span class="string">&quot;Soft Threshold (power)&quot;</span>,ylab=<span class="string">&quot;Scale Free Topology Model Fit,signed R^2&quot;</span>,type=<span class="string">&quot;n&quot;</span>,</span><br><span class="line">      main = paste(<span class="string">&quot;Scale independence&quot;</span>));</span><br><span class="line">text(sft$fitIndices[,<span class="number">1</span>], -sign(sft$fitIndices[,<span class="number">3</span>])*sft$fitIndices[,<span class="number">2</span>],</span><br><span class="line">      labels=powers,cex=cex1,col=<span class="string">&quot;red&quot;</span>);</span><br><span class="line"><span class="comment"># this line corresponds to using an R^2 cut-off of h</span></span><br><span class="line">abline(h=<span class="number">0.85</span>,col=<span class="string">&quot;red&quot;</span>)</span><br><span class="line"><span class="comment"># Mean connectivity as a function of the soft-thresholding power</span></span><br><span class="line">plot(sft$fitIndices[,<span class="number">1</span>], sft$fitIndices[,<span class="number">5</span>],</span><br><span class="line">      xlab=<span class="string">&quot;Soft Threshold (power)&quot;</span>,ylab=<span class="string">&quot;Mean Connectivity&quot;</span>, type=<span class="string">&quot;n&quot;</span>,</span><br><span class="line">      main = paste(<span class="string">&quot;Mean connectivity&quot;</span>))</span><br><span class="line">text(sft$fitIndices[,<span class="number">1</span>], sft$fitIndices[,<span class="number">5</span>], labels=powers, cex=cex1,col=<span class="string">&quot;red&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="/images/wgcna/soft.png" alt="soft"></p><blockquote><p>假如没有合适的阈值，在官方文档中说，如果是unsigned的就选6，如果是signed的就选12.  </p></blockquote><h3 id="2-网络构建"><a href="#2-网络构建" class="headerlink" title="2. 网络构建"></a>2. 网络构建</h3><h4 id="一步法构建"><a href="#一步法构建" class="headerlink" title="一步法构建"></a>一步法构建</h4><p><code>WGCNA</code>提供了<code>blockwiseModules</code>函数可以一步计算出所有的模块</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##一步法网络构建：One-step network construction and module detection</span></span><br><span class="line"><span class="comment"># numericLabels: 返回数字而不是颜色作为模块的名字，后面可以再转换为颜色</span></span><br><span class="line"><span class="comment"># saveTOMs：最耗费时间的计算，存储起来，供后续使用</span></span><br><span class="line"><span class="comment"># mergeCutHeight: 合并模块的阈值，越大模块越</span></span><br><span class="line">net = blockwiseModules(datExpr, power = power, maxBlockSize = <span class="number">6000</span>,</span><br><span class="line">                       TOMType = type, minModuleSize = <span class="number">30</span>,</span><br><span class="line">                       reassignThreshold = <span class="number">0</span>, mergeCutHeight = <span class="number">0.25</span>,</span><br><span class="line">                       numericLabels = <span class="literal">TRUE</span>, pamRespectsDendro = <span class="literal">FALSE</span>,</span><br><span class="line">                       saveTOMs=<span class="literal">TRUE</span>, corType = corType, </span><br><span class="line">                       maxPOutliers=maxPOutliers, loadTOMs=<span class="literal">TRUE</span>,</span><br><span class="line">                       saveTOMFileBase = paste0(exprMat, <span class="string">&quot;.tom&quot;</span>), <span class="comment">## 保存tom矩阵</span></span><br><span class="line">                       verbose = <span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>展示最终层级聚类的结果  </p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 灰色的为未分到模块的基因。</span></span><br><span class="line"><span class="comment"># Convert labels to colors for plotting</span></span><br><span class="line">moduleLabels = net$colors</span><br><span class="line">moduleColors = labels2colors(moduleLabels)</span><br><span class="line"><span class="comment"># Plot the dendrogram and the module colors underneath</span></span><br><span class="line">plotDendroAndColors(net$dendrograms[[<span class="number">1</span>]], moduleColors[net$blockGenes[[<span class="number">1</span>]]],</span><br><span class="line">                    <span class="string">&quot;Module colors&quot;</span>,</span><br><span class="line">                    dendroLabels = <span class="literal">FALSE</span>, hang = <span class="number">0.03</span>,</span><br><span class="line">                    addGuide = <span class="literal">TRUE</span>, guideHang = <span class="number">0.05</span>)</span><br></pre></td></tr></table></figure><p><img src="/images/wgcna/cluster.png" alt="cluster"></p><h4 id="分步构建"><a href="#分步构建" class="headerlink" title="分步构建"></a>分步构建</h4><p>首先计算邻接矩阵  </p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># calculate the adjacency</span></span><br><span class="line">softPower = <span class="number">6</span>;</span><br><span class="line">adjacency = adjacency(datExpr, power = softPower);</span><br></pre></td></tr></table></figure><p>将邻接矩阵转换成拓扑重叠矩阵  </p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Turn adjacency into topological overlap</span></span><br><span class="line">TOM = TOMsimilarity(adjacency);</span><br><span class="line">dissTOM = <span class="number">1</span>-TOM</span><br></pre></td></tr></table></figure><p>对TOM进行聚类  </p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Call the hierarchical clustering function</span></span><br><span class="line">geneTree = hclust(as.dist(dissTOM), method = <span class="string">&quot;average&quot;</span>);</span><br><span class="line"><span class="comment"># Plot the resulting clustering tree (dendrogram)</span></span><br><span class="line">plot(geneTree, xlab=<span class="string">&quot;&quot;</span>, sub=<span class="string">&quot;&quot;</span>, main = <span class="string">&quot;Gene clustering on TOM-based dissimilarity&quot;</span>,</span><br><span class="line">     labels = <span class="literal">FALSE</span>, hang = <span class="number">0.04</span>);</span><br></pre></td></tr></table></figure><p><img src="/images/wgcna/tree.png" alt="tree"></p><p>上面得到了基因聚类的树，我们对这棵树进行剪枝得到不同的模块  </p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># We like large modules, so we set the minimum module size relatively high:</span></span><br><span class="line">minModuleSize = <span class="number">30</span>;</span><br><span class="line"><span class="comment"># Module identification using dynamic tree cut:</span></span><br><span class="line">dynamicMods = cutreeDynamic(dendro = geneTree, distM = dissTOM,</span><br><span class="line">                            deepSplit = <span class="number">2</span>, pamRespectsDendro = <span class="literal">FALSE</span>,</span><br><span class="line">                            minClusterSize = minModuleSize);</span><br><span class="line">table(dynamicMods)</span><br></pre></td></tr></table></figure><p>得到模块后我们就可以看到不同的模块表示 </p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Convert numeric lables into colors</span></span><br><span class="line">dynamicColors = labels2colors(dynamicMods)</span><br><span class="line">table(dynamicColors)</span><br><span class="line"><span class="comment"># Plot the dendrogram and colors underneath</span></span><br><span class="line">plotDendroAndColors(geneTree, dynamicColors, <span class="string">&quot;Dynamic Tree Cut&quot;</span>,</span><br><span class="line">                    dendroLabels = <span class="literal">FALSE</span>, hang = <span class="number">0.03</span>,</span><br><span class="line">                    addGuide = <span class="literal">TRUE</span>, guideHang = <span class="number">0.05</span>,</span><br><span class="line">                    main = <span class="string">&quot;Gene dendrogram and module colors&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="/images/wgcna/cuttree.png" alt="cuttree">  </p><p>这样我们就得到了不同的基因表达模块。然而在这时某些模块之间也有可能具有很高的相似性，为了进一步衡量这些模块之间的共表达相似性，我们计算了eigengenes然后计算他们之间的相似性。  </p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">MEList = moduleEigengenes(datExpr, colors = dynamicColors)</span><br><span class="line">MEs = MEList$eigengenes</span><br><span class="line"><span class="comment"># Calculate dissimilarity of module eigengenes</span></span><br><span class="line">MEDiss = <span class="number">1</span>-cor(MEs);</span><br><span class="line"><span class="comment"># Cluster module eigengenes</span></span><br><span class="line">METree = hclust(as.dist(MEDiss), method = <span class="string">&quot;average&quot;</span>);</span><br><span class="line"><span class="comment"># Plot the result</span></span><br><span class="line">plot(METree, main = <span class="string">&quot;Clustering of module eigengenes&quot;</span>,</span><br><span class="line">xlab = <span class="string">&quot;&quot;</span>, sub = <span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="comment"># 在这里选取0.25作为阈值对eigengenes进行合并  </span></span><br><span class="line">MEDissThres = <span class="number">0.25</span></span><br><span class="line"><span class="comment"># Plot the cut line into the dendrogram</span></span><br><span class="line">abline(h=MEDissThres, col = <span class="string">&quot;red&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="/images/wgcna/eigengenes.png" alt="eigengenes">  </p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Call an automatic merging function</span></span><br><span class="line">merge = mergeCloseModules(datExpr, dynamicColors, cutHeight = MEDissThres, verbose = <span class="number">3</span>)</span><br><span class="line"><span class="comment"># The merged module colors</span></span><br><span class="line">mergedColors = merge$colors;</span><br><span class="line"><span class="comment"># Eigengenes of the new merged modules:</span></span><br><span class="line">mergedMEs = merge$newMEs;</span><br><span class="line">plotDendroAndColors(geneTree, cbind(dynamicColors, mergedColors),</span><br><span class="line">                    c(<span class="string">&quot;Dynamic Tree Cut&quot;</span>, <span class="string">&quot;Merged dynamic&quot;</span>),</span><br><span class="line">                    dendroLabels = <span class="literal">FALSE</span>, hang = <span class="number">0.03</span>,</span><br><span class="line">                    addGuide = <span class="literal">TRUE</span>, guideHang = <span class="number">0.05</span>)</span><br></pre></td></tr></table></figure><p><img src="/images/wgcna/mergetree.png" alt="mergetree">  </p><blockquote><p>这个结果其实和一步计算的结果基本一致,得到模块数目相同  </p></blockquote><h3 id="3-模块之间的相关性"><a href="#3-模块之间的相关性" class="headerlink" title="3. 模块之间的相关性"></a>3. 模块之间的相关性</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># module eigengene, 可以绘制线图，作为每个模块的基因表达趋势的展示</span></span><br><span class="line">MEs = net$MEs</span><br><span class="line">MEs_col = MEs</span><br><span class="line">colnames(MEs_col) = paste0(<span class="string">&quot;ME&quot;</span>, labels2colors(</span><br><span class="line">  as.numeric(str_replace_all(colnames(MEs),<span class="string">&quot;ME&quot;</span>,<span class="string">&quot;&quot;</span>))))</span><br><span class="line">MEs_col = orderMEs(MEs_col)</span><br><span class="line"><span class="comment"># marDendro/marHeatmap 设置下、左、上、右的边距</span></span><br><span class="line">plotEigengeneNetworks(MEs_col, <span class="string">&quot;Eigengene adjacency heatmap&quot;</span>, </span><br><span class="line">                      marDendro = c(<span class="number">3</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>),</span><br><span class="line">                      marHeatmap = c(<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">2</span>), plotDendrograms = <span class="literal">T</span>, </span><br><span class="line">                      xLabelsAngle = <span class="number">90</span>)</span><br></pre></td></tr></table></figure><p><img src="/images/wgcna/eiheatmap.png" alt="eiheatmap">  </p><h3 id="4-样本和性状的聚类关系"><a href="#4-样本和性状的聚类关系" class="headerlink" title="4. 样本和性状的聚类关系"></a>4. 样本和性状的聚类关系</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">nGenes = ncol(datExpr)</span><br><span class="line">nSamples = nrow(datExpr)</span><br><span class="line"><span class="comment">#首先针对样本做个系统聚类</span></span><br><span class="line">datExpr_tree&lt;-hclust(dist(datExpr), method = <span class="string">&quot;average&quot;</span>)</span><br><span class="line">sample_colors &lt;- numbers2colors(as.numeric(factor(datTraits$subtype)), </span><br><span class="line">                                colors = c(<span class="string">&quot;white&quot;</span>,<span class="string">&quot;blue&quot;</span>,<span class="string">&quot;red&quot;</span>,<span class="string">&quot;green&quot;</span>),signed = <span class="literal">FALSE</span>)</span><br><span class="line">par(mar = c(<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">1</span>),cex=<span class="number">0.8</span>)</span><br><span class="line">plotDendroAndColors(datExpr_tree, sample_colors,</span><br><span class="line">                      groupLabels = colnames(sample),</span><br><span class="line">                      cex.dendroLabels = <span class="number">0.8</span>,</span><br><span class="line">                      marAll = c(<span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">1</span>),</span><br><span class="line">                      cex.rowText = <span class="number">0.01</span>,</span><br><span class="line">                      main = <span class="string">&quot;Sample dendrogram and trait heatmap&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="/images/wgcna/sample-subtype-cluster.png" alt="sample_subtype">  </p><p>条形图展示  </p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Luminal = as.data.frame(design[,<span class="number">3</span>]);</span><br><span class="line">names(Luminal) = <span class="string">&quot;Luminal&quot;</span></span><br><span class="line">y=Luminal</span><br><span class="line">GS1=as.numeric(cor(y,datExpr, use=<span class="string">&quot;p&quot;</span>))</span><br><span class="line">GeneSignificance=abs(GS1)</span><br><span class="line"><span class="comment"># Next module significance is defined as average gene significance.</span></span><br><span class="line">ModuleSignificance=tapply(GeneSignificance,</span><br><span class="line">                          moduleColors, mean, na.rm=<span class="literal">T</span>)</span><br><span class="line">sizeGrWindow(<span class="number">8</span>,<span class="number">7</span>)</span><br><span class="line">par(mfrow = c(<span class="number">1</span>,<span class="number">1</span>))</span><br><span class="line"><span class="comment"># 如果模块太多，下面的展示就不友好</span></span><br><span class="line"><span class="comment"># 不过，我们可以自定义出图。</span></span><br><span class="line">plotModuleSignificance(GeneSignificance,moduleColors)</span><br></pre></td></tr></table></figure><p><img src="/images/wgcna/bar.png" alt="bar">  </p><h3 id="5-可视化基因网络"><a href="#5-可视化基因网络" class="headerlink" title="5. 可视化基因网络"></a>5. 可视化基因网络</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">nSelect = <span class="number">400</span></span><br><span class="line"><span class="comment"># For reproducibility, we set the random seed</span></span><br><span class="line">set.seed(<span class="number">10</span>);</span><br><span class="line">select = sample(nGenes, size = nSelect);</span><br><span class="line">selectTOM = dissTOM[select, select];</span><br><span class="line"><span class="comment"># There’s no simple way of restricting a clustering tree to a subset of genes, so we must re-cluster.</span></span><br><span class="line">selectTree = hclust(as.dist(selectTOM), method = <span class="string">&quot;average&quot;</span>)</span><br><span class="line">selectColors = moduleColors[select];</span><br><span class="line">plotDiss = selectTOM^<span class="number">7</span>;</span><br><span class="line">diag(plotDiss) = <span class="literal">NA</span>;</span><br><span class="line">TOMplot(plotDiss, selectTree, selectColors, main = <span class="string">&quot;Network heatmap plot, selected genes&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="/images/wgcna/geneheatmap.png" alt="geneheatmap">  </p><h3 id="6-模块和性状的关系"><a href="#6-模块和性状的关系" class="headerlink" title="6. 模块和性状的关系"></a>6. 模块和性状的关系</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">nGenes = ncol(datExpr)</span><br><span class="line">nSamples = nrow(datExpr)</span><br><span class="line">design=model.matrix(~<span class="number">0</span>+ datTraits$subtype)</span><br><span class="line">colnames(design)=levels(datTraits$subtype)</span><br><span class="line">moduleColors &lt;- labels2colors(net$colors)</span><br><span class="line"><span class="comment"># Recalculate MEs with color labels</span></span><br><span class="line">MEs0 = moduleEigengenes(datExpr, moduleColors)$eigengenes</span><br><span class="line">MEs = orderMEs(MEs0); <span class="comment">##不同颜色的模块的ME值矩 (样本vs模块)</span></span><br><span class="line">moduleTraitCor = cor(MEs, design , use = <span class="string">&quot;p&quot;</span>);</span><br><span class="line">moduleTraitPvalue = corPvalueStudent(moduleTraitCor, nSamples)</span><br><span class="line"></span><br><span class="line">sizeGrWindow(<span class="number">10</span>,<span class="number">6</span>)</span><br><span class="line"><span class="comment"># Will display correlations and their p-values</span></span><br><span class="line">textMatrix = paste(signif(moduleTraitCor, <span class="number">2</span>), <span class="string">&quot;\n(&quot;</span>,</span><br><span class="line">                   signif(moduleTraitPvalue, <span class="number">1</span>), <span class="string">&quot;)&quot;</span>, sep = <span class="string">&quot;&quot;</span>);</span><br><span class="line">dim(textMatrix) = dim(moduleTraitCor)</span><br><span class="line">par(mar = c(<span class="number">6</span>, <span class="number">8.5</span>, <span class="number">3</span>, <span class="number">3</span>));</span><br><span class="line"><span class="comment"># Display the correlation values within a heatmap plot</span></span><br><span class="line">labeledHeatmap(Matrix = moduleTraitCor,</span><br><span class="line">               xLabels = colnames(design),</span><br><span class="line">               yLabels = names(MEs),</span><br><span class="line">               ySymbols = names(MEs),</span><br><span class="line">               colorLabels = <span class="literal">FALSE</span>,</span><br><span class="line">               colors = greenWhiteRed(<span class="number">50</span>),</span><br><span class="line">               textMatrix = textMatrix,</span><br><span class="line">               setStdMargins = <span class="literal">FALSE</span>,</span><br><span class="line">               cex.text = <span class="number">0.5</span>,</span><br><span class="line">               zlim = c(-<span class="number">1</span>,<span class="number">1</span>),</span><br><span class="line">               main = paste(<span class="string">&quot;Module-trait relationships&quot;</span>))</span><br></pre></td></tr></table></figure><p><img src="/images/wgcna/Module-trait-relationships.png" alt="moduletrait">  </p><p>从上图已经可以看到跟乳腺癌分类相关的基因模块了，包括<code>Basal</code> 、<code>Claudin-low</code> 、<code>Luminal</code> 、<code>Non-malignant</code>、<code>unknown</code> 这5类所对应的不同模块的基因列表。可以看到每一种乳腺癌都有跟它强烈相关的模块，可以作为它的表达signature，模块里面的基因可以拿去做下游分析。我们看到<strong>Luminal表型</strong>跟<strong>棕色的模块</strong>相关性高达0.86，而且极其显著的相关，所以值得我们挖掘，这<strong>个模块里面的基因是什么，为什么如此的相关呢？</strong>  </p><h3 id="7-感兴趣模块的具体分析"><a href="#7-感兴趣模块的具体分析" class="headerlink" title="7. 感兴趣模块的具体分析"></a>7. 感兴趣模块的具体分析</h3><p>性状跟模块虽然求出了相关性，可以挑选最相关的那些模块来分析，但是模块本身仍然包含非常多的基因，还需进一步的寻找最重要的基因。所有的模块都可以跟基因算出相关系数，所有的连续型性状也可以跟基因的表达值算出相关系数。 <strong>如果跟性状显著相关基因也跟某个模块显著相关，那么这些基因可能就非常重要</strong>。  </p><h4 id="计算模块与基因的相关性矩阵"><a href="#计算模块与基因的相关性矩阵" class="headerlink" title="计算模块与基因的相关性矩阵"></a>计算模块与基因的相关性矩阵</h4><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># names (colors) of the modules</span></span><br><span class="line">modNames = substring(names(MEs), <span class="number">3</span>)</span><br><span class="line"><span class="comment">## 算出每个模块跟基因的皮尔森相关系数矩阵</span></span><br><span class="line">geneModuleMembership = as.data.frame(cor(datExpr, MEs, use = <span class="string">&quot;p&quot;</span>));</span><br><span class="line">MMPvalue = as.data.frame(corPvalueStudent(as.matrix(geneModuleMembership), nSamples));</span><br><span class="line">names(geneModuleMembership) = paste(<span class="string">&quot;MM&quot;</span>, modNames, sep=<span class="string">&quot;&quot;</span>);</span><br><span class="line">names(MMPvalue) = paste(<span class="string">&quot;p.MM&quot;</span>, modNames, sep=<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="计算性状与基因的相关性矩阵"><a href="#计算性状与基因的相关性矩阵" class="headerlink" title="计算性状与基因的相关性矩阵"></a>计算性状与基因的相关性矩阵</h4><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 只有连续型性状才能只有计算</span></span><br><span class="line"><span class="comment">## 这里把是否属于 Luminal 表型这个变量用0,1进行数值化。</span></span><br><span class="line">Luminal = as.data.frame(design[,<span class="number">3</span>]);</span><br><span class="line">names(Luminal) = <span class="string">&quot;Luminal&quot;</span></span><br><span class="line">geneTraitSignificance = as.data.frame(cor(datExpr, Luminal, use = <span class="string">&quot;p&quot;</span>));</span><br><span class="line">GSPvalue = as.data.frame(corPvalueStudent(as.matrix(geneTraitSignificance), nSamples));</span><br><span class="line">names(geneTraitSignificance) = paste(<span class="string">&quot;GS.&quot;</span>, names(Luminal), sep=<span class="string">&quot;&quot;</span>);</span><br><span class="line">names(GSPvalue) = paste(<span class="string">&quot;p.GS.&quot;</span>, names(Luminal), sep=<span class="string">&quot;&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="指定感兴趣模块进行分析"><a href="#指定感兴趣模块进行分析" class="headerlink" title="指定感兴趣模块进行分析"></a>指定感兴趣模块进行分析</h4><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">module = <span class="string">&quot;brown&quot;</span></span><br><span class="line">column = match(module, modNames);</span><br><span class="line">moduleGenes = moduleColors==module;</span><br><span class="line">sizeGrWindow(<span class="number">7</span>, <span class="number">7</span>)</span><br><span class="line">par(mfrow = c(<span class="number">1</span>,<span class="number">1</span>))</span><br><span class="line">verboseScatterplot(abs(geneModuleMembership[moduleGenes, column]),</span><br><span class="line">                     abs(geneTraitSignificance[moduleGenes, <span class="number">1</span>]),</span><br><span class="line">                     xlab = paste(<span class="string">&quot;Module Membership in&quot;</span>, module, <span class="string">&quot;module&quot;</span>),</span><br><span class="line">                     ylab = <span class="string">&quot;Gene significance for Luminal&quot;</span>,</span><br><span class="line">                     main = paste(<span class="string">&quot;Module membership vs. gene significance\n&quot;</span>),</span><br><span class="line">                     cex.main = <span class="number">1.2</span>, cex.lab = <span class="number">1.2</span>, cex.axis = <span class="number">1.2</span>, col = module)</span><br></pre></td></tr></table></figure><p><img src="/images/wgcna/cor.png" alt="cor">  </p><p>可以看到这些基因不仅仅是跟其对应的模块高度相关，而且是跟其对应的性状高度相关，进一步说明了基因值得深度探究。  </p><h3 id="8-提取指定模块的基因名"><a href="#8-提取指定模块的基因名" class="headerlink" title="8. 提取指定模块的基因名"></a>8. 提取指定模块的基因名</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Select module</span></span><br><span class="line">module = <span class="string">&quot;brown&quot;</span>;</span><br><span class="line"><span class="comment"># Select module probes</span></span><br><span class="line">probes = colnames(datExpr) <span class="comment">## 我们例子里面的probe就是基因</span></span><br><span class="line">inModule = (moduleColors==module);</span><br><span class="line">modProbes = probes[inModule]; </span><br><span class="line">head(modProbes)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果使用WGCNA包自带的热图就很丑。</span></span><br><span class="line">which.module=<span class="string">&quot;brown&quot;</span>;</span><br><span class="line">dat=datExpr[,moduleColors==which.module ] </span><br><span class="line">plotMat(t(scale(dat)),nrgcols=<span class="number">30</span>,rlabels=<span class="literal">T</span>,</span><br><span class="line">        clabels=<span class="literal">T</span>,rcols=which.module,</span><br><span class="line">        title=which.module )</span><br><span class="line">datExpr[<span class="number">1</span>:<span class="number">4</span>,<span class="number">1</span>:<span class="number">4</span>]</span><br><span class="line">dat=t(datExpr[,moduleColors==which.module ] )</span><br><span class="line"><span class="keyword">library</span>(pheatmap)</span><br><span class="line">pheatmap(dat ,show_colnames =<span class="literal">F</span>,show_rownames = <span class="literal">F</span>) <span class="comment">#对那些提取出来的1000个基因所在的每一行取出，组合起来为一个新的表达矩阵</span></span><br><span class="line">n=t(scale(t(log(dat+<span class="number">1</span>)))) <span class="comment"># &#x27;scale&#x27;可以对log-ratio数值进行归一化</span></span><br><span class="line">n[n&gt;<span class="number">2</span>]=<span class="number">2</span> </span><br><span class="line">n[n&lt; -<span class="number">2</span>]= -<span class="number">2</span></span><br><span class="line">n[<span class="number">1</span>:<span class="number">4</span>,<span class="number">1</span>:<span class="number">4</span>]</span><br><span class="line">pheatmap(n,show_colnames =<span class="literal">F</span>,show_rownames = <span class="literal">F</span>)</span><br><span class="line">group_list=datTraits$subtype</span><br><span class="line">ac=data.frame(g=group_list)</span><br><span class="line">rownames(ac)=colnames(n) </span><br><span class="line">pheatmap(n,show_colnames =<span class="literal">F</span>,show_rownames = <span class="literal">F</span>,</span><br><span class="line">         annotation_col=ac )</span><br><span class="line"><span class="comment"># 可以很清晰的看到，所有的形状相关的模块基因</span></span><br><span class="line"><span class="comment"># 其实未必就不是差异表达基因。</span></span><br></pre></td></tr></table></figure><p><img src="/images/wgcna/heatmap.png" alt="heatmap">  </p><p>有了基因信息，后边就可以进行GO/KEGG等功能数据库的注释  </p><h3 id="9-模块导出"><a href="#9-模块导出" class="headerlink" title="9. 模块导出"></a>9. 模块导出</h3><p>主要模块里面的基因直接的相互作用关系信息可以导出到<strong>cytoscape</strong>,<strong>VisANT</strong>等网络可视化软件。  </p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Select module</span></span><br><span class="line">module = <span class="string">&quot;brown&quot;</span>;</span><br><span class="line"><span class="comment"># Select module probes</span></span><br><span class="line">probes = colnames(datExpr) <span class="comment">## 我们例子里面的probe就是基因名</span></span><br><span class="line">inModule = (moduleColors==module);</span><br><span class="line">modProbes = probes[inModule]; </span><br><span class="line"><span class="comment">## 也是提取指定模块的基因名</span></span><br><span class="line"><span class="comment"># Select the corresponding Topological Overlap</span></span><br><span class="line">modTOM = TOM[inModule, inModule];</span><br><span class="line">dimnames(modTOM) = list(modProbes, modProbes)</span><br></pre></td></tr></table></figure><p>导出到<strong>cytoscape</strong>  </p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cyt = exportNetworkToCytoscape(</span><br><span class="line">      modTOM,</span><br><span class="line">     edgeFile = paste(<span class="string">&quot;CytoscapeInput-edges-&quot;</span>, paste(module, collapse=<span class="string">&quot;-&quot;</span>), <span class="string">&quot;.txt&quot;</span>, sep=<span class="string">&quot;&quot;</span>),</span><br><span class="line">     nodeFile = paste(<span class="string">&quot;CytoscapeInput-nodes-&quot;</span>, paste(module, collapse=<span class="string">&quot;-&quot;</span>), <span class="string">&quot;.txt&quot;</span>, sep=<span class="string">&quot;&quot;</span>),</span><br><span class="line">     weighted = <span class="literal">TRUE</span>,</span><br><span class="line">     threshold = <span class="number">0.02</span>,</span><br><span class="line">     nodeNames = modProbes, </span><br><span class="line">     nodeAttr = moduleColors[inModule]);</span><br></pre></td></tr></table></figure><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ol><li><a href="https://www.jianshu.com/p/e9cc3f43441d">WGCNA分析，简单全面的最新教程</a>  </li><li><a href="https://horvath.genetics.ucla.edu/html/CoexpressionNetwork/">https://horvath.genetics.ucla.edu/html/CoexpressionNetwork/</a>  </li></ol>]]></content>
      
      
      <categories>
          
          <category> WGCNA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WGCNA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单尾还是双尾检验</title>
      <link href="2020/08/10/one-tail/"/>
      <url>2020/08/10/one-tail/</url>
      
        <content type="html"><![CDATA[<p>单侧检验 or 双侧检验？</p><a id="more"></a>  <h2 id="单尾检验与双尾检验"><a href="#单尾检验与双尾检验" class="headerlink" title="单尾检验与双尾检验"></a>单尾检验与双尾检验</h2><ul><li><strong>假设有一个新的肿瘤治疗方案，我们希望新治疗方案的疗效较传统治疗更好</strong>  </li><li><strong>为了探究新的抗肿瘤治疗方案是否疗效更优，故进行含6个患者的小临床试验，其中3个患者接受传统治疗方案，另外3个患者接受新的治疗方案。</strong>将治疗疗效结果表示在坐标轴上，从左至右表示疗效从好至差。该数据提示新治疗方案的疗效似乎更好，但是有部分数据并未得出此结论（如下），故两种方案的疗效优劣并不明确。  </li></ul><p><img src="/images/one-tail/onetail1.jpg" alt="img1">  </p><p><img src="/images/one-tail/onetail2.jpg" alt="img2">  </p><p>进行统计学检验：  </p><ul><li><strong>在单尾检验时，得出p值=0.03，p值小于常见显著性水平的阈值0.05。</strong>  </li><li><strong>在双尾检验时，得出p值=0.06，p值大于常见显著性水平阈值0.05。</strong>  </li></ul><p>那么在这种情况下应该选择哪个计算的阈值？  </p><p>单尾检验得出的p值检验的假设是： <strong>主观认为新治疗方案的疗效更好</strong>，故假设是否新的治疗方案优于传统治疗方案；该检验假设并没有区分新治疗方案疗效劣于和等于传统治疗方案的情况。  </p><p>双尾检验得出的p值检验的假设是： <strong>对两种方案的疗效无主观判定</strong>，故假设是否新的治疗方案优于或劣于或等于传统治疗方案。  </p><p><strong>因为在实际试验中，大多数情况下我们并不能知道两种方案疗效的优劣，我们需要探究的是新治疗方案是否优于或劣于或等于传统治疗方案，故我们应该选用双尾检验</strong>。尽管在此次小样本临床试验中，新治疗方案似乎比传统方案更优，但是我们也必须考虑新方案劣于传统方案的情况。好的统计检验意味着，我们必须在试验实施前确定检验方案和显著性水平。否则就会发生p-hacking，它会增加我们报告虚假结果的机会（bogus results）。  </p><p><strong>故，在以上这种情况下，我们应该考虑采用双尾t检验，得出新方案与传统方案疗效无显著差异的结论</strong>（p值=0.06）。  </p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在大多数情况下，我们并不知道目标数据差异的方向和好坏， 因此<strong>我们既需要考虑一组数据高于另一组数据的情况，也需要考虑一组数据低于另一组数据的情况，故我们往往需要选取双尾检验以减少假阳性率。</strong>  </p><hr><p><strong>Reference</strong>  </p><p><a href="https://www.youtube.com/watch?v=bsZGt-caXO4&amp;list=PLblh5JKOoLUK0FLuzwntyYI10UQFUhsY9&amp;index=30">https://www.youtube.com/watch?v=bsZGt-caXO4&amp;list=PLblh5JKOoLUK0FLuzwntyYI10UQFUhsY9&amp;index=30</a>  </p>]]></content>
      
      
      <categories>
          
          <category> statistics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> stats </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>R Docker tutorial</title>
      <link href="2020/07/31/r-docker-tutorial/"/>
      <url>2020/07/31/r-docker-tutorial/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><p>这是专门为具有 R 和 RStudio 知识的朋友设计的 Docker 教程。该介绍旨在帮助需要 Docker 进行项目的人们。我们首先解释 Docker 是什么以及为什么有用。然后，我们将详细介绍如何将其用于可复制的分析项目。  </p><h2 id="开始之前"><a href="#开始之前" class="headerlink" title="开始之前"></a>开始之前</h2><p>在开始之前，请根据下面的指南安装需要的Docker：  </p><ul><li><a href="https://docs.docker.com/mac/step_one/">mac</a>  </li><li><a href="https://docs.docker.com/linux/step_one/">linux</a>  </li><li><a href="https://docs.docker.com/windows/step_one/">windows</a>  </li></ul><h2 id="什么是-Docker？为什么我要使用它？"><a href="#什么是-Docker？为什么我要使用它？" class="headerlink" title="什么是 Docker？为什么我要使用它？"></a>什么是 Docker？为什么我要使用它？</h2><h3 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h3><ul><li>理解 Docker 的基本思想  </li><li>了解为什么 Docker 非常有用  </li></ul><h3 id="为什么要使用Docker"><a href="#为什么要使用Docker" class="headerlink" title="为什么要使用Docker"></a>为什么要使用Docker</h3><p>想象一下，你正在 R 中进行分析，然后将代码发送给朋友。你的朋友在完全相同的数据集上运行此代码，但结果略有不同。这可能有多种原因，例如操作系统不同，R 软件包的版本不同等。Docker 可以解决这样的问题。  </p><p><strong>可以将Docker容器视为你计算机内部的一台计算机</strong>。这个虚拟计算机的妙处在于你可以将其发送给你的朋友。当他们启动计算机并运行你的代码时，他们将获得与你完全相同的结果。  </p><p><img src="/images/r-docker-tutorial/computerception.jfif" alt="computerception">  </p><p>简单来说，你因为下面的一些原因使用 Docker：  </p><ul><li>它允许你解决从操作系统到R或latex版本上的依赖  </li><li>它使你的分析可重复  </li></ul><p>还有一些 Docker 可以发挥用处的地方：  </p><ul><li>可移植性：由于 Docker 容器可以轻松地发送到另一台机器，因此你可以在自己的计算机上设置好所有内容，然后在更强大的机器上运行分析。  </li><li>可共享性：你可以将 Docker 容器发送给任何知道如何使用 Docker 的人。  </li></ul><h3 id="基本词汇"><a href="#基本词汇" class="headerlink" title="基本词汇"></a>基本词汇</h3><p>下面会经常出现<strong>镜像</strong>和<strong>容器</strong>这两个词。镜像的实例称为容器。镜像是虚拟计算机的设置。如果运行此镜像，将拥有它的一个实例，我们将其称为容器。可以有多个运行相同镜像的容器。  </p><h2 id="在-Docker-中启动-RStudio"><a href="#在-Docker-中启动-RStudio" class="headerlink" title="在 Docker 中启动 RStudio"></a>在 Docker 中启动 RStudio</h2><h3 id="学习目标-1"><a href="#学习目标-1" class="headerlink" title="学习目标"></a>学习目标</h3><ul><li>在 Docker 中启动 RStudio  </li><li>将磁盘与 Docker 镜像链接  </li><li>载入容器  </li></ul><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>首先参考 <a href="https://docs.docker.com/get-started/">install Docker</a> 进行安装，没有必要完成链接中所有的教程，有需要再回看它们。  </p><h3 id="在-Docker-中启动-RStudio-1"><a href="#在-Docker-中启动-RStudio-1" class="headerlink" title="在 Docker 中启动 RStudio"></a>在 Docker 中启动 RStudio</h3><p>要启动 Docker，我们需要做的第一件事是打开一个 <code>Unix Shell</code>。如果你在<code>Mac</code>或<code>Windows</code> 上，在最后一步，你安装了一个叫<em>Docker快速启动终端</em>;现在打开它——它看起来应该像一个普通的 shell 提示符(<code>~$</code>)，但实际上它指向的是一个 Docker 默认运行的 linux 虚拟机，而在本教程的其余部分，除非另有说明，你应该在这里完成所有操作。如果您在 linux 机器上，那么您可以使用旧的终端提示符。</p><p>在 <code>Mac</code>上，你也可以选择你的终端并配置 Docker使用。特别是如果你得到错误，不能连接到Docker守护进程。Docker 守护进程是否在此主机上运行?。在教程的某个时候，运行下面的命令可能会解决你的问题:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eval &quot;$(docker-machine env default)&quot;</span><br></pre></td></tr></table></figure><p>接下来，我们将让Docker运行一个已经存在的映像，我们会使用来自<a href="https://github.com/rocker-org/rocker/wiki">Rocker</a>的<code>verse</code>Docker镜像。它将允许我们在容器内运行RStudio，并且已经安装了许多有用的R包。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --rm -p 8787:8787 rocker&#x2F;verse</span><br></pre></td></tr></table></figure><p><code>--rm</code>、<code>-p</code>是允许你自定义如何运行容器的标志。<code>-p</code>告诉 Docker 你将使用一个端口在你的浏览器中看到 RStudio(我们随后指定为端口<code>8787:8787</code>), <code>—rm</code> 确保当我们退出容器时，容器被删除。如果我们不这样做，每次我们运行一个容器，它的一个版本将被保存到我们的本地计算机。这最终会导致大量磁盘空间的浪费，直到我们手动删除这些容器。稍后，我们将向你展示如何保存容器(如果你想这样做的话)。  </p><p>如果你尝试运行一个没有在本地安装的 Docker 容器，那么Docker会自动在Docker Hub(一个在线的Docker 镜像存储库)上搜索该容器，如果它存在，就下载它。  </p><p>上面的命令将导致 RStudio-Server 不可见地启动。要连接到它，打开一个浏览器，输入<code>http://</code>，然后加上你的 <code>ip</code> 地址，再加上<code>:8787</code>。如果您运行的是 Mac 或 Windows 机器，您将在启动 Docker Quickstart终端时出现在终端中的第一行文本中找到 ip 地址。例如，你应该会看到:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">                        ##         .</span><br><span class="line">                  ## ## ##        &#x3D;&#x3D;</span><br><span class="line">               ## ## ## ## ##    &#x3D;&#x3D;&#x3D;</span><br><span class="line">           &#x2F;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;\___&#x2F; &#x3D;&#x3D;&#x3D;</span><br><span class="line">      ~~~ &#123;~~ ~~~~ ~~~ ~~~~ ~~~ ~ &#x2F;  &#x3D;&#x3D;&#x3D;- ~~~</span><br><span class="line">           \______ o           __&#x2F;</span><br><span class="line">             \    \         __&#x2F;</span><br><span class="line">              \____\_______&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">docker is configured to use the default machine with IP 192.168.99.100</span><br><span class="line">For help getting started, check out the docs at https:&#x2F;&#x2F;docs.docker.com</span><br></pre></td></tr></table></figure><p>你应该在浏览器中键入 URL <code>http://192.168.99.100:8787</code>  </p><p>如果你在一台 Linux 机器上运行，你可以使用 localhost 作为 ip 地址，例如：<code>http://localhost:8787</code>  </p><p>这将会将你导向 RStudio 登录界面，使用下面的信息登录：  </p><p>username: <code>rstudio</code> password: <code>rstudio</code>  </p><p>现在你就可以在浏览器中使用 RStudio 工作了，就像你使用 Rstudio 桌面版一样。</p><p>下面是一个截图示例：  </p><p><img src="/images/r-docker-tutorial/Rstudio.png" alt="Rstudio">  </p><p>现在尝试查看虚拟计算机的文件(docker容器)。点击<code>File -&gt; Open File</code>,你将看到当前没有文件。原因是这个镜像现在没有文件。然后打开一个新的R脚本，例如：<code>file -&gt; New file -&gt; R Script</code>，然后j键入以下脚本，并保存：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># make x the numbers from 1 to 5, and y the numbers from 6-10</span><br><span class="line">x &lt;- 1:5</span><br><span class="line">y &lt;- 6:10</span><br><span class="line"></span><br><span class="line"># plot x against y</span><br><span class="line">plot(x, y)</span><br></pre></td></tr></table></figure><p>如果您现在再次查看您的文件，您将看到建立的脚本文件。  </p><p>因为我们刚才启动镜像时使用了 <code>--rm</code> 标记，所以在这个机器上创建的任何东西在关闭后都会消失。你可以试试将上面的代码保存为一个文件，然后关闭浏览器，在终端上用 <code>Ctrl+C</code> 关掉容器，然后重新启动容器，看是否创建的文件是否依然存在。  </p><h3 id="将磁盘与-Docker-镜像连接以便于访问和保存数据文件"><a href="#将磁盘与-Docker-镜像连接以便于访问和保存数据文件" class="headerlink" title="将磁盘与 Docker 镜像连接以便于访问和保存数据文件"></a>将磁盘与 Docker 镜像连接以便于访问和保存数据文件</h3><p>这就引出了一个问题，如果在退出容器时删除了容器，我们如何保存我们的工作?一种解决方案是将卷(例如本地硬盘驱动器)链接到容器，这样您就可以访问那里的数据并在那里保存数据。  </p><p>这一次当我们启动容器时使用 <code>-v</code> 标记指定我们项目的根目录，如下所示（你的目录可能有所不同），:左边是你本地计算机的路径，右边是容器里的路径，一般以 /home/rstudio/ 开始（这个镜像已经默认创建了用户名 RStudio 和进行了相关配置）  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --rm -p 8787:8787 -v &#x2F;Users&#x2F;tiffanytimbers&#x2F;Documents&#x2F;DC&#x2F;r-docker-tutorial:&#x2F;home&#x2F;rstudio&#x2F;r-docker-tutorial rocker&#x2F;verse</span><br></pre></td></tr></table></figure><p>然后你就可以再一次的在浏览器中打开Rstudio  </p><p>这一次你在 Docker 容器中启动 RStudio 后，你可以查看到下面映射的文件目录。然后就可以载入数据进行分析工作了：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># load gapminder data from a csv on your computer</span><br><span class="line">gap5yr &lt;- read.csv(file &#x3D; &#39;data&#x2F;gapminder-FiveYearData.csv&#39;)</span><br></pre></td></tr></table></figure><p>画一个分析图  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># load ggplot library</span><br><span class="line">library(ggplot2)</span><br><span class="line"></span><br><span class="line"># plot GDP against  life expectancy</span><br><span class="line">qplot(gap5yr$lifeExp, gap5yr$gdpPercap)</span><br><span class="line"></span><br><span class="line"># save the plot</span><br><span class="line">ggsave(filename &#x3D; &#39;data&#x2F;GDP_LifeExp.pdf&#39;)</span><br></pre></td></tr></table></figure><p>让我们将脚本保存为 <code>plot_GDP_LifeExp.R</code>，然后关闭容器，看在本地目录下是否能看到脚本和绘图文件。  </p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>在这节课中，我们学习了如何启动Docker容器来允许我们在浏览器中运行RStudio。我们知道在运行Docker时使用<code>-rm</code>标志会使容器短暂;这意味着它会在我们关闭容器后被自动删除。我们这样做是为了不在我们的机器上积累大量的容器和浪费空间。我们还了解到，如果我们想访问和保存数据、脚本和任何其他文件，我们可以将笔记本电脑的一个卷连接到Docker容器。  </p><p>我们使用的容器已经安装了R、RStudio和几个有用的R包。在后面的课程中，我们将学习如何修改这个容器来安装新的包，以及在哪里可以找到对我们的工作可能有用的其他Docker容器。  </p><h2 id="安装-R-包"><a href="#安装-R-包" class="headerlink" title="安装 R 包"></a>安装 R 包</h2><h3 id="在-RStudio-内安装-R-包"><a href="#在-RStudio-内安装-R-包" class="headerlink" title="在 RStudio 内安装 R 包"></a>在 RStudio 内安装 R 包</h3><p>您可以通过使用<code>install.packages()</code>在浏览器中使用RStudio安装R包，就像在桌面RStudio上一样。让我们像以前一样启动一个<code>verse</code> Docker容器来运行RStudio，并尝试安装<code>gapminder</code>包，加载它并查看数据。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># install package</span><br><span class="line">install.packages(&#39;gapminder&#39;)</span><br><span class="line"></span><br><span class="line"># load library</span><br><span class="line">library(gapminder)</span><br><span class="line"></span><br><span class="line"># peek at data</span><br><span class="line">head(gapminder)</span><br></pre></td></tr></table></figure><p>太好了！现在我们已经安装好包并可以进行工作。但是等等，如果我们退出了容器会发生什么？安装的包会被删除，因为我们没有保存这个版本的 Docker 镜像。我们需要创建一个镜像，这样当利用它创建一个新的容器时，<code>gapminder</code> 包也已经安装好了，可以直接使用。  </p><p>为了做到这一点，我们需要运行 <code>docker commit</code>（类似 <code>git commit</code>）保存修改。记住，这个操作需要在关闭容器前运行，一般我们另外打开一个终端进行这个操作。  </p><p>我们可以使用下面的命令进行查看（类似 linux <code>ps</code> 命令）：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure><p>输出应该类似下面展示，哈希值记录了容器 ID：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4a6a528b35da        rocker&#x2F;verse        &quot;&#x2F;init&quot;             2 minutes ago       Up 2 minutes        0.0.0.0:8787-&gt;8787&#x2F;tcp   silly_meninsky</span><br></pre></td></tr></table></figure><p>现在我们在新的终端中运行下面命令，并记录修改信息：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit -m &quot;verse + gapminder&quot; 4a6a528b35da verse_gapminder</span><br></pre></td></tr></table></figure><p>为了保存这个Docker映像，我们必须提供一个提交消息来描述我们对映像所做的更改。我们通过传递<code>-m</code>标志，后跟引号中的消息来实现这一点。我们还需要为这个版本的容器(这里是<code>4a6a528b35da</code>)提供特定的散列。最后，我们还为新映像提供一个新名称。我们将这个新图像命名为<code>verse_gapminder</code>。  </p><p>我们可以看到，我们现在有两个Docker镜像保存在我们的电脑上  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images </span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">REPOSITORY                           TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">verse_gapminder                      latest              bb38976d03cf        57 seconds ago      1.955 GB</span><br><span class="line">rocker&#x2F;verse                         latest              0168d115f220        3 days ago          1.954 GB</span><br></pre></td></tr></table></figure><p>你可以通过从每个映像运行Docker容器来测试它是否工作。您将发现<code>Gapminder</code>包只安装在<code>verse_gapminder</code>映像上，而没有安装在<code>rocker/verse</code>映像上。  </p><h3 id="安装-R-系统外部依赖"><a href="#安装-R-系统外部依赖" class="headerlink" title="安装 R 系统外部依赖"></a>安装 R 系统外部依赖</h3><p>许多R包都有R外部的依赖关系，例如<code>GSL</code>、<code>GDAL</code>、<code>JAGS</code>等等。要在正在运行的rocker容器上安装这些文件，您需要进入docker命令行(在一个新的终端窗口中)并键入以下命令:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker ps # find the ID of the running container you want to add a package to</span><br><span class="line">docker exec -it &lt;container-id&gt; bash # a docker command to start a bash shell in your container</span><br><span class="line">apt-get install libgsl0-dev # install the package, in this case GSL</span><br></pre></td></tr></table></figure><p>如果您在运行<code>apt-get install libgsl0-dev</code>时报错，尝试先运行<code>apt-get update</code>。  </p><p>为了保存安装的依赖，依旧需要进行修改的提交：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit -m &quot;verse + gapminder + GSL&quot; &lt;container id&gt;  verse_gapminder_gsl</span><br></pre></td></tr></table></figure><p>现在，您可以进入输入<code>docker exec</code>命令的终端窗口，并通过输入<code>exit</code>关闭docker容器  </p><h2 id="对-Docker-Hub-推送或拉取镜像"><a href="#对-Docker-Hub-推送或拉取镜像" class="headerlink" title="对 Docker Hub 推送或拉取镜像"></a>对 Docker Hub 推送或拉取镜像</h2><h3 id="学习目标-2"><a href="#学习目标-2" class="headerlink" title="学习目标"></a>学习目标</h3><ul><li>理解镜像来自哪里  </li><li>从 Docker Hub 拉取镜像  </li><li>推送镜像到 Docker Hub  </li></ul><h3 id="从-Docker-Hub-获取镜像"><a href="#从-Docker-Hub-获取镜像" class="headerlink" title="从 Docker Hub 获取镜像"></a>从 Docker Hub 获取镜像</h3><p><a href="https://hub.docker.com/">Docker Hub</a> 是一个存储 Docker 镜像的地方，当我们运行下面的命令时，软件首选检查镜像是否存在于你的计算机上。如果不存在，它会自动去 Docker Hub 搜索和下载。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --rm -p 8787:8787 rocker&#x2F;verse</span><br></pre></td></tr></table></figure><p>如果你想要从 Docker Hub 上拉取镜像而不运行它，可以使用命令：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull rocker&#x2F;verse</span><br></pre></td></tr></table></figure><h3 id="将镜像放到-Docker-Hub"><a href="#将镜像放到-Docker-Hub" class="headerlink" title="将镜像放到 Docker Hub"></a>将镜像放到 Docker Hub</h3><p>想象一下如果你自己创建了一个镜像，然后想要与其他人分享，你可以在 <a href="https://hub.docker.com/">https://hub.docker.com/</a> 创建一个账号。验证完邮箱之后，你就可以将你的镜像上传了：  </p><ol><li>登录 <a href="https://hub.docker.com/">https://hub.docker.com/</a>  </li><li>点击创建仓库  </li><li>设置名字后点击创建  </li><li>使用命令行登录 Docker Hub  </li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker login --username&#x3D;yourhubusername --email&#x3D;youremail@company.com</span><br></pre></td></tr></table></figure><p>当提示输入你的密码。如果一切正常，您将得到一个类似的消息  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WARNING: login credentials saved in &#x2F;home&#x2F;username&#x2F;.docker&#x2F;config.json</span><br><span class="line">Login Succeeded</span><br></pre></td></tr></table></figure><ol start="5"><li>检查镜像的 ID  </li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><p>然后你会看到类似下面的输出：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">REPOSITORY              TAG       IMAGE ID         CREATED           SIZE</span><br><span class="line">verse_gapminder_gsl     latest    023ab91c6291     3 minutes ago     1.975 GB</span><br><span class="line">verse_gapminder         latest    bb38976d03cf     13 minutes ago    1.955 GB</span><br><span class="line">rocker&#x2F;verse            latest    0168d115f220     3 days ago        1.954 GB</span><br></pre></td></tr></table></figure><p>然后标记你的镜像  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker tag bb38976d03cf yourhubusername&#x2F;verse_gapminder:firsttry</span><br></pre></td></tr></table></figure><p>这里镜像 ID 必须匹配，<code>fisttry</code> 是标签，一般选择一些容易识别的标签。  </p><ol start="6"><li>推送你的镜像：  </li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push yourhubusername&#x2F;verse_gapminder</span><br></pre></td></tr></table></figure><p>现在所有人都可以使用你的镜像了！  </p><h3 id="保存和加载镜像"><a href="#保存和加载镜像" class="headerlink" title="保存和加载镜像"></a>保存和加载镜像</h3><p>将镜像推送到 Docker Hub 非常使用，但它有些缺点：</p><ol><li>受带宽限制  </li><li>推送意味着发布（私密需要额外付费） </li><li>当在一些计算节点上工作时，如果每一次你都拉取 Docker Hub 的镜像，速度会很慢  </li></ol><p>解决方案的在本地对你的镜像进行存档，这样你可以在需要的时候轻松载入。  </p><p>为了这一目的，你可以使用 <code>docker save</code> 命令。例如，让我们保存一个我们制作的<code>verse_gapminder</code> docker镜像的本地副本:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker save verse_gapminder &gt; verse_gapminder.tar</span><br></pre></td></tr></table></figure><p>如果我们想要从存档中载入镜像，使用下面的命令：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker load --input verse_gapminder.tar</span><br></pre></td></tr></table></figure><h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><p>前面我们学习了一个可以在 Docker 中运行 RStudio 的基础镜像，学习如何使用 <code>docker commit</code> 修改镜像的内容。这是一个非常棒的技术，它让我们可以进行重复，但如果我们想要更简单地修改镜像中的内容，并有一份清晰的记录，该怎么办呢？这在维护运行环境时非常有用，这些环境可能会随着项目的变化而发展，<code>Dockerfiles</code>可以帮助维护这些环境。  </p><p><code>Dockerfiles</code>是一组关于如何向基本映像添加内容的指令。它们在一系列层中构建自定义图像。在一个名为<code>Dockerfile</code>的新文件中，放入以下内容:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FROM rocker&#x2F;verse:latest</span><br></pre></td></tr></table></figure><p>这告诉 Docker 以 <code>rocker/verse</code> 基础镜像作为开始。<code>FROM</code> 命令必须是第一条指令。  </p><p>接下来，让我们基于该基础镜像添加一层，让 <code>gapminder</code> 提取安装好可以直接使用：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RUN R -e &quot;install.packages(&#39;gapminder&#39;, repos &#x3D; &#39;http:&#x2F;&#x2F;cran.us.r-project.org&#39;)&quot;</span><br></pre></td></tr></table></figure><p><code>RUN</code> 命令可以执行 Shell 命令，这个例子中，我们直接通过 Shell 调用包安装命令。保存你的 <code>Dockerfile</code>，返回终端，现在我们可以利用下面的命令构建一个自定义镜像：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t my-r-image .</span><br></pre></td></tr></table></figure><p><code>-t my-r-image</code>  指定镜像名字（要小写），. 指定构建镜像所需要的资源来源，这里指当前目录。查看镜像：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><p>你应该在列表中看到<code>my-r-image</code>。启动你的新镜像:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --rm -p 8787:8787 my-r-image</span><br></pre></td></tr></table></figure><p>在 RStudio 控制台中尝使用<code>gapminder</code>：  </p><figure class="highlight plain"><figcaption><span>eval</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">library(&#39;gapminder&#39;)</span><br><span class="line">gapminder</span><br></pre></td></tr></table></figure><p>现在，<code>gapminder</code>已经被预装好了，可以进入你的新docker镜像了。  </p><p>有时候我们想要添加一些静态文件到镜像中，这可以使用 <code>ADD</code> 命令：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ADD data&#x2F;gapminder-FiveYearData.csv &#x2F;home&#x2F;rstudio&#x2F;</span><br></pre></td></tr></table></figure><p>重新建立你的Docker镜像  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t my-r-image .</span><br></pre></td></tr></table></figure><p>然后再次启动它  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --rm -p 8787:8787 my-r-image</span><br></pre></td></tr></table></figure><p>在浏览器中返回到RStudio, <code>gapmin - fiveyeardata .csv</code>将出现在RStudio可见的文件中。通过这种方式，我们可以捕获文件作为Docker映像的一部分，因此它们始终与映像的其余部分处于完全相同的状态。  </p><h3 id="高级技巧：缓存层"><a href="#高级技巧：缓存层" class="headerlink" title="高级技巧：缓存层"></a>高级技巧：缓存层</h3><p>在构建和重构建你的 Docker 镜像时，你可能注意到了类似下面的输出：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Step 2 : RUN R -e &quot;install.packages(&#39;gapminder&#39;, repos &#x3D; &#39;http:&#x2F;&#x2F;cran.us.r-project.org&#39;)&quot;</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; fa9be67b52d1</span><br></pre></td></tr></table></figure><p>注意到使用的是命令的缓存版本。当你重新构建映像时，Docker 会检查该映像的以前版本，以查看以前是否执行了相同的命令；每一个步骤都被保存为一个单独的层，Docker 非常聪明，可以重用那些层，如果它们没有改变，并且和前面一样的顺序。因此，一旦你弄清楚了你的安装过程的一部分(特别是如果它是一个缓慢的部分)，把它放在你的Dockerfile的顶部，不要在这些行上面或中间放任何东西，特别是那些经常变化的东西;这可以大大加快你的构建过程。  </p><blockquote><p>简单的说，重构建只修改有变动的步骤，如果很多命令没有问题，尽量放到顶部。  </p></blockquote><h2 id="共享你的所有分析"><a href="#共享你的所有分析" class="headerlink" title="共享你的所有分析"></a>共享你的所有分析</h2><p>现在我们已经学习了如何使用dockerfile，我们可以将所有分析发送给协作者。我们将共享一个包含运行分析、数据和分析所需的所有依赖项的映像。  </p><p>我们将通过dockerfile构建此镜像。我们以基础的<code>verse rocker</code>镜像开始。这一次我们希望拥有一个特定的R版本(3.3.2)。可以通过给镜像加上标签实现。这对于我们重现是非常有用的。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FROM rocker&#x2F;verse:3.3.2</span><br></pre></td></tr></table></figure><p>作为我们分析的一部分，我们将使用<code>gapminder</code>数据。我们需要将这个包安装到docker映像中。让我们通过修改dockerfile来安装这个包。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RUN R -e &quot;install.packages(&#39;gapminder&#39;, repos &#x3D; &#39;http:&#x2F;&#x2F;cran.us.r-project.org&#39;)&quot;</span><br></pre></td></tr></table></figure><p>现在我们只需要进行数据分析并将其添加到dockerfile中。  </p><p>为了进行分析，我们将创建一个预期寿命与人均gdp的图表。  </p><p>在一个新的R脚本上，让我们写以下分析内容:  </p><figure class="highlight plain"><figcaption><span>eval</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">library(ggplot2)</span><br><span class="line">library(gapminder)</span><br><span class="line"></span><br><span class="line">life_expentancy_plot &lt;- ggplot(data &#x3D; gapminder) + </span><br><span class="line">    geom_point(aes(x &#x3D; lifeExp, y &#x3D; gdpPercap, colour &#x3D; continent)) </span><br></pre></td></tr></table></figure><p>我们将把这个脚本保存为<code>analysis.R</code>并将其添加到dockerfile中。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ADD analysis.R &#x2F;home&#x2F;rstudio&#x2F;</span><br></pre></td></tr></table></figure><p>现在，我们可以构建映像并检查是否有想要与协作者共享的所有内容。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t my-analysis .</span><br></pre></td></tr></table></figure><p>我们的镜像将出现在镜像列表当中  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><p>启动你的新镜像，检查你所有想要的信息:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -dp 8787:8787 my-analysis</span><br></pre></td></tr></table></figure><p>所有的信息都包含在镜像里了。  </p><p>现在我们可以把我们的分析推到dockerhub。  </p><p>在DockerHub上点击创建仓库，选取一个仓库名字（例如：<code>gapminder_my_analysis</code>）和一个描述，点击创建  </p><p>从命令行登录到Docker Hub  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker login --username&#x3D;yourhubusername --email&#x3D;youremail@company.com</span><br></pre></td></tr></table></figure><p>登录认证后检查本地的镜像ID：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><p>你将会看到类似的信息  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">REPOSITORY                         TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">my-analysis                      latest              dc63d4790eaa        2 minutes ago       3.164 GB</span><br></pre></td></tr></table></figure><p>标记你的镜像  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker tag dc63d4790eaa yourhubusername&#x2F;gapminder_my_analysis:firsttry</span><br></pre></td></tr></table></figure><p>将映像推到创建的存储库  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push yourhubusername&#x2F;gapminder_my_analysis</span><br></pre></td></tr></table></figure><p>现在每个人都可以使用你的镜像。  </p><p>其他人可以使用以下命令获取你的镜像  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull yourhubusername&#x2F;gapminder_my_analysis:firsttry</span><br></pre></td></tr></table></figure><p>现在他们就拥有了你所有的信息。  </p><hr><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="http://ropenscilabs.github.io/r-docker-tutorial/">http://ropenscilabs.github.io/r-docker-tutorial/</a>  </p>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
          <category> R </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker 学习笔记(一)</title>
      <link href="2020/06/08/docker-i/"/>
      <url>2020/06/08/docker-i/</url>
      
        <content type="html"><![CDATA[<a id="more"></a> <h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p><strong>Docker</strong> 是一个开源的应用容器引擎，基于 <strong>Go 语言</strong> 并遵从 <code>Apache2.0</code> 协议开源。  </p><p><strong>Docker</strong> 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。  </p><h3 id="Docker的应用场景"><a href="#Docker的应用场景" class="headerlink" title="Docker的应用场景"></a>Docker的应用场景</h3><ul><li>Web 应用的自动化打包和发布。  </li><li>自动化测试和持续集成、发布。  </li><li>在服务型环境中部署和调整数据库或其他的后台应用。  </li><li>从头编译或者扩展现有的 OpenShift 或 Cloud Foundry 平台来搭建自己的 PaaS 环境。  </li></ul><h2 id="docker-安装"><a href="#docker-安装" class="headerlink" title="docker 安装"></a>docker 安装</h2><p><code>Docker</code> 的旧版本被称为 <code>docker</code>，<code>docker.io</code> 或 <code>docker-engine</code> 。如果已安装，请卸载它们：  </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get remove docker docker-engine docker.io containerd runc</span><br></pre></td></tr></table></figure><p>首先安装依赖:  </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install apt-transport-https ca-certificates curl gnupg2 software-properties-common</span><br></pre></td></tr></table></figure><p>添加信任 Docker 的 GPG 公钥:  </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</span><br></pre></td></tr></table></figure><p>对于 amd64 架构的计算机，添加软件仓库:  </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository \</span><br><span class="line">   <span class="string">&quot;deb [arch=amd64] https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/ubuntu \</span></span><br><span class="line"><span class="string">   <span class="subst">$(lsb_release -cs)</span> \</span></span><br><span class="line"><span class="string">   stable&quot;</span></span><br></pre></td></tr></table></figure><p>最后安装  </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install docker-ce</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker --version</span><br><span class="line"><span class="comment">## Docker version 19.03.11, build 42e35e61f3</span></span><br></pre></td></tr></table></figure><h2 id="Hello-world"><a href="#Hello-world" class="headerlink" title="Hello world"></a>Hello world</h2><p><code>Docker</code> 允许你在容器内运行应用程序， 使用 <code>docker run</code> 命令来在容器内运行一个应用程序。  </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run ubuntu:15.10 /bin/<span class="built_in">echo</span> <span class="string">&quot;Hello world&quot;</span></span><br><span class="line"><span class="comment">## hello world</span></span><br></pre></td></tr></table></figure><p>参数解析：  </p><ul><li><strong>docker</strong> : Docker 的执行命令  </li><li><strong>run</strong> : 与<code>docker</code>命令组合运行一个特定的容器  </li><li><strong>ubuntu:15.10</strong> : 指定要运行的镜像，<code>Docker</code> 首先从本地主机上查找镜像是否存在，如果不存在，<code>Docker</code> 就会从镜像仓库 <code>Docker Hub</code> 下载公共镜像。  </li><li><strong>/bin/echo “Hello world”</strong> : 在启动的容器里执行的命令  </li></ul><p>连起来就是：<code>Docker 以 ubuntu15.10 镜像创建一个新容器，然后在容器里执行 bin/echo &quot;Hello world&quot;，然后输出结果。</code>  </p><h2 id="交互运行"><a href="#交互运行" class="headerlink" title="交互运行"></a>交互运行</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@VM-0-11-ubuntu:~$ sudo docker run -i -t ubuntu:15.10 /bin/bash</span><br><span class="line">root@2401df9ef044:/<span class="comment"># </span></span><br></pre></td></tr></table></figure><ul><li><strong>-t</strong>: 在新容器内指定一个伪终端或终端。  </li><li><strong>-i</strong>: 允许你对容器内的标准输入进行交互。  </li></ul><p>通过运行 <code>exit</code> 命令或者使用 <code>CTRL+D</code> 来退出容器。  </p><h2 id="后台运行"><a href="#后台运行" class="headerlink" title="后台运行"></a>后台运行</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@VM-0-11-ubuntu:~$ sudo docker run -d ubuntu:15.10 /bin/sh -c <span class="string">&quot;while true; do echo hello world; sleep 1; done&quot;</span></span><br><span class="line">9db349c972802d3a7627b27d3c9eb0c58888ad0c80a001b5d7e6f08813eed876</span><br></pre></td></tr></table></figure><p>输出的长字符串叫做容器 ID，对每个容器来说都是唯一的，我们可以通过容器 ID 来查看对应的容器发生了什么  </p><p>可以通过 <code>docker ps</code> 来查看容器的运行情况  </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@VM-0-11-ubuntu:~$ sudo docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES</span><br><span class="line">9db349c97280        ubuntu:15.10        <span class="string">&quot;/bin/sh -c &#x27;while t…&quot;</span>   11 seconds ago      Up 10 seconds                           tender_black</span><br></pre></td></tr></table></figure><p>输出详情介绍:  </p><ul><li><strong>CONTAINER ID</strong>: 容器 ID。  </li><li><strong>IMAGE</strong>: 使用的镜像。  </li><li><strong>COMMAND</strong>: 启动容器时运行的命令。  </li><li><strong>CREATED</strong>: 容器的创建时间。  </li><li><strong>STATUS</strong>: 容器状态。  </li><li><strong>PORTS</strong>: 容器的端口信息和使用的连接类型（tcp\udp）。  </li><li><strong>NAMES</strong>: 自动分配的容器名称。  </li></ul><blockquote><p>docker 运行有七种状态  </p><ul><li>created（已创建）  </li><li>restarting（重启中）  </li><li>running（运行中）  </li><li>removing（迁移中）  </li><li>paused（暂停）  </li><li>exited（停止）  </li><li>dead（死亡）  </li></ul></blockquote><p>使用<code>docker logs</code>查看输出结果  </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@VM-0-11-ubuntu:~$ sudo docker logs tender_black</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure><p>使用<code>docker stop</code>停止容器  </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@VM-0-11-ubuntu:~$ sudo docker stop tender_black</span><br><span class="line">tender_black</span><br></pre></td></tr></table></figure><h2 id="docker-用户"><a href="#docker-用户" class="headerlink" title="docker 用户"></a>docker 用户</h2><p>docker进程使用Unix Socket而不是TCP端口。而默认情况下，Unix socket属于root用户，需要root权限才能访问。  </p><p>解决方案：  </p><ol><li>使用sudo获取管理员权限，运行docker命令  </li><li>docker守护进程启动的时候，会默认赋予名字为docker的用户组读写Unix socket的权限，因此只要创建docker用户组，并将当前用户加入到docker用户组中，那么当前用户就有权限访问Unix socket了，进而也就可以执行docker相关命令  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo groupadd docker     <span class="comment">#添加docker用户组</span></span><br><span class="line">sudo gpasswd -a <span class="variable">$USER</span> docker     <span class="comment">#将登陆用户加入到docker用户组中</span></span><br><span class="line">newgrp docker     <span class="comment">#更新用户组</span></span><br><span class="line">docker ps    <span class="comment">#测试docker命令是否可以使用sudo正常使用</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Screen命令的使用</title>
      <link href="2019/04/04/screen/"/>
      <url>2019/04/04/screen/</url>
      
        <content type="html"><![CDATA[<p>screen常用命令</p><a id="more"></a><p>使用telnet或SSH远程登录linux时，如果连接非正常中断，重新连接时，系统将开一个新的session，无法恢复原来的 session.screen命令可以解决这个问题。Screen工具是一个终端多路转接器，在本质上，这意味着你能够使用一个单一的终端窗口运行多终端的应用。  </p><p>screen命令介绍   </p><ol><li>screen -S  创建一个screen（可以用screen -S ID，打开一个指定的ID session）</li><li>screen -ls 显示所有的screen会话  </li><li>screen -d  脱离当前screen ,返回正常shell  </li><li>screen -r  进入指定screen  </li><li>screen -S SEEION_NAME -X quit 删除镜像  </li></ol><p>Screen 操作快捷键  </p><ul><li>ctrl-a c：创建一个新的 Shell  </li><li>ctrl-a ctrl-a：在 Shell 间切换  </li><li>ctrl-a n：切换到下一个 Shell  </li><li>ctrl-a p：切换到上一个 Shell  </li><li>ctrl-a 0…9：同样是切换各个 Shell  </li><li>ctrl-a d：退出 Screen 会话  </li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> screen </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>R的文件操作</title>
      <link href="2019/04/01/file-r/"/>
      <url>2019/04/01/file-r/</url>
      
        <content type="html"><![CDATA[<p>在R中操作文件  </p><a id="more"></a>  <h2 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h2><h3 id="查看目录"><a href="#查看目录" class="headerlink" title="查看目录"></a>查看目录</h3><p><code>getwd()</code> 列出当前工作路径  </p><p><code>setwd()</code> 设置工作路径  </p><p><code>list.files()</code>和<code>dir()</code>的用法相同，可以列出路径下的文件和目录  </p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">list.files(path =<span class="string">&quot;.&quot;</span>, pattern = <span class="literal">NULL</span>, all.files = <span class="literal">FALSE</span>,</span><br><span class="line"></span><br><span class="line">           full.names = <span class="literal">FALSE</span>, recursive =<span class="literal">FALSE</span>,</span><br><span class="line"></span><br><span class="line">           ignore.case = <span class="literal">FALSE</span>, include.dirs =<span class="literal">FALSE</span>, no.. = <span class="literal">FALSE</span>)</span><br><span class="line"></span><br><span class="line">dir(path =<span class="string">&quot;.&quot;</span>, pattern = <span class="literal">NULL</span>, all.files = <span class="literal">FALSE</span>,</span><br><span class="line"></span><br><span class="line">    full.names = <span class="literal">FALSE</span>, recursive = <span class="literal">FALSE</span>,</span><br><span class="line"></span><br><span class="line">    ignore.case = <span class="literal">FALSE</span>, include.dirs = <span class="literal">FALSE</span>,no.. = <span class="literal">FALSE</span>)</span><br></pre></td></tr></table></figure><p>函数<code>list.dirs()</code>只列出路径下所有目录,默认是递归进行的  </p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.dirs(path = <span class="string">&quot;.&quot;</span>, full.names = <span class="literal">TRUE</span>, recursive = <span class="literal">TRUE</span>)</span><br></pre></td></tr></table></figure><p>参数介绍：</p><p><code>path</code> 路径，如不填则默认为当前工作路径，即<code>getwd()</code>得到的路径；<br><code>pattern</code> 正则表达式，若<code>pattern</code>不为<code>NULL</code>，返回文件（目录）名满足该正则表达式的文件（目录）；<br><code>all.files </code>若为<code>FALSE</code>则不显示隐藏文件（目录），若为<code>TRUE</code>则返回所有文件（目录）；<br><code>full.names</code> 若为<code>FALSE</code>则只返回文件（目录）名，若为<code>TRUE</code>则返回文件（目录）路径；<br><code>recursive</code> 若为<code>FALSE</code>则只返回该路径的子级文件（目录），若为<code>TRUE</code>则递归返回所有子、孙文件（目录）；<br><code>ignore.case</code> 若为<code>TRUE</code>则在匹配pattern时不区分大小写；<br><code>include.dirs</code> 在recursive为TURE，即显示所有子、孙文件时，若<code>include.dirs</code>为FALSE则只列出最终端的文件名，而不列出中间层级的目录名；<br><code>no.. </code>若为TRUE，则不显示“.”和“..”。  </p><h3 id="查看目录的权限"><a href="#查看目录的权限" class="headerlink" title="查看目录的权限"></a>查看目录的权限</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; file.info(<span class="string">&quot;.&quot;</span>)</span><br><span class="line">  size isdir mode               mtime               ctime               atime exe</span><br><span class="line">.    <span class="number">0</span>  <span class="literal">TRUE</span>  <span class="number">555</span> <span class="number">2019</span>-<span class="number">03</span>-<span class="number">13</span> <span class="number">08</span>:<span class="number">10</span>:<span class="number">19</span> <span class="number">2018</span>-<span class="number">10</span>-<span class="number">13</span> <span class="number">17</span>:<span class="number">14</span>:<span class="number">40</span> <span class="number">2019</span>-<span class="number">04</span>-<span class="number">01</span> <span class="number">18</span>:<span class="number">54</span>:<span class="number">24</span>  no</span><br></pre></td></tr></table></figure><h3 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h3><h4 id="创建单个目录"><a href="#创建单个目录" class="headerlink" title="创建单个目录"></a>创建单个目录</h4><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; dir.create(<span class="string">&quot;create&quot;</span>)</span><br><span class="line">&gt; list.dirs()</span><br><span class="line">[<span class="number">1</span>] <span class="string">&quot;.&quot;</span>        <span class="string">&quot;./create&quot;</span> <span class="string">&quot;./tmp&quot;</span></span><br></pre></td></tr></table></figure><h4 id="递归创建目录"><a href="#递归创建目录" class="headerlink" title="递归创建目录"></a>递归创建目录</h4><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; dir.create(path=<span class="string">&quot;a1/b2/c3&quot;</span>,recursive = <span class="literal">TRUE</span>)</span><br><span class="line">&gt; list.dirs()</span><br><span class="line">[<span class="number">1</span>] <span class="string">&quot;.&quot;</span>          <span class="string">&quot;./a1&quot;</span>       <span class="string">&quot;./a1/b2&quot;</span>    <span class="string">&quot;./a1/b2/c3&quot;</span> <span class="string">&quot;./create&quot;</span>  <span class="string">&quot;./tmp&quot;</span></span><br></pre></td></tr></table></figure><h4 id="检测目录是否存在"><a href="#检测目录是否存在" class="headerlink" title="检测目录是否存在"></a>检测目录是否存在</h4><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; file.exists(<span class="string">&quot;a&quot;</span>)</span><br><span class="line">[<span class="number">1</span>] <span class="literal">FALSE</span></span><br></pre></td></tr></table></figure><h4 id="检查目录的权限"><a href="#检查目录的权限" class="headerlink" title="检查目录的权限"></a>检查目录的权限</h4><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; df &lt;- dir(file.path(R.home(), <span class="string">&quot;bin&quot;</span>), full.names = <span class="literal">T</span>)</span><br><span class="line">&gt; file.access(df, mode = <span class="number">0</span>) == <span class="number">0</span></span><br><span class="line">  D:/Rcore/bin/config.sh       D:/Rcore/bin/R.exe D:/Rcore/bin/Rscript.exe </span><br><span class="line">                    <span class="literal">TRUE</span>                     <span class="literal">TRUE</span>                     <span class="literal">TRUE</span> </span><br><span class="line">        D:/Rcore/bin/x64 </span><br><span class="line">                    <span class="literal">TRUE</span></span><br></pre></td></tr></table></figure><p>mode = 0, 检查文件或目录是否存在<br>mode = 1, 检查文件或目录是否可执行<br>mode = 2, 检查文件或目录是否可写<br>mode = 4, 检查文件或目录是否可读  </p><blockquote><p>file.access()返回的是逻辑值，file.info()返回的是详细的权限信息  </p></blockquote><h4 id="修改目录权限"><a href="#修改目录权限" class="headerlink" title="修改目录权限"></a>修改目录权限</h4><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Sys.chmod(list.dirs(<span class="string">&quot;.&quot;</span>), <span class="string">&quot;777&quot;</span>)</span><br><span class="line">f &lt;- list.files(<span class="string">&quot;.&quot;</span>, all.files = <span class="literal">TRUE</span>, full.names = <span class="literal">TRUE</span>, recursive = <span class="literal">TRUE</span>)</span><br><span class="line">Sys.chmod(f, (file.info(f)$mode | <span class="string">&quot;664&quot;</span>))</span><br></pre></td></tr></table></figure><h4 id="对目录重名"><a href="#对目录重名" class="headerlink" title="对目录重名"></a>对目录重名</h4><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对tmp目录重命名</span></span><br><span class="line">&gt; file.rename(<span class="string">&quot;tmp&quot;</span>, <span class="string">&quot;tmp2&quot;</span>)</span><br><span class="line">[<span class="number">1</span>] <span class="literal">TRUE</span></span><br></pre></td></tr></table></figure><h4 id="删除目录"><a href="#删除目录" class="headerlink" title="删除目录"></a>删除目录</h4><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除tmp2目录</span></span><br><span class="line">&gt; unlink(<span class="string">&quot;tmp2&quot;</span>, recursive = <span class="literal">TRUE</span>)</span><br></pre></td></tr></table></figure><h4 id="其他功能"><a href="#其他功能" class="headerlink" title="其他功能"></a>其他功能</h4><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 拼接目录字符串</span></span><br><span class="line">&gt; file.path(<span class="string">&quot;p1&quot;</span>,<span class="string">&quot;p2&quot;</span>,<span class="string">&quot;p3&quot;</span>)</span><br><span class="line">[<span class="number">1</span>] <span class="string">&quot;p1/p2/p3&quot;</span></span><br><span class="line"><span class="comment"># 最底层子目录或文件名</span></span><br><span class="line">&gt; filename&lt;-<span class="string">&#x27;C:/test/lalala.txt&#x27;</span></span><br><span class="line">&gt; basename(filename)</span><br><span class="line">[<span class="number">1</span>] <span class="string">&quot;lalala.txt&quot;</span></span><br><span class="line"><span class="comment"># 最底层子目录</span></span><br><span class="line">&gt; dirname(filename)r</span><br><span class="line">[<span class="number">1</span>] <span class="string">&quot;C:/test&quot;</span></span><br><span class="line"><span class="comment"># 转换扩展路径</span></span><br><span class="line">&gt; path.expand(<span class="string">&quot;~/foo&quot;</span>)</span><br><span class="line">[<span class="number">1</span>] <span class="string">&quot;/home/conan/foo&quot;</span></span><br></pre></td></tr></table></figure><h2 id="常规文件操作"><a href="#常规文件操作" class="headerlink" title="常规文件操作"></a>常规文件操作</h2><p>cat(“file A\n”, file=”A”) #创建一个文件A，文件内容是’file A’,’\n’表示换行，这是一个很好的习惯</p><p>cat(“file B\n”, file=”B”) #创建一个文件B</p><p>file.append(“A”, “B”) #将文件B的内容附到A内容的后面，注意没有空行</p><p>file.create(“A”) #创建一个文件A, 注意会覆盖原来的文件</p><p>file.append(“A”, rep(“B”, 10)) #将文件B的内容复制10便，并先后附到文件A内容后</p><p>file.show(“A”) #新开工作窗口显示文件A的内容</p><p>file.copy(“A”, “C”) #复制文件A保存为C文件，同一个文件夹</p><p>dir.create(“tmp”) #创建名为tmp的文件夹</p><p>file.copy(c(“A”, “B”), “tmp”) #将文件夹拷贝到tmp文件夹中</p><p>list.files(“tmp”) #查看文件夹tmp中的文件名</p><p>unlink(“tmp”, recursive=F) #如果文件夹tmp为空，删除文件夹tmp</p><p>unlink(“tmp”, recursive=TRUE) #删除文件夹tmp，如果其中有文件一并删除</p><p>file.remove(“A”, “B”, “C”) #移除三个文件  </p><h2 id="特殊目录"><a href="#特殊目录" class="headerlink" title="特殊目录"></a>特殊目录</h2><ul><li>R.home() 查看R软件的相关目录</li><li>.Library 查看R核心包的目录</li><li>.Library.site 查看R核心包的目录和root用户安装包目录</li><li>.libPaths() 查看R所有包的存放目录</li><li>system.file() 查看指定包所在的目录  </li></ul>]]></content>
      
      
      <categories>
          
          <category> R </category>
          
      </categories>
      
      
        <tags>
            
            <tag> base </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jekyll-theme-next添加Valine评论系统</title>
      <link href="2019/03/18/valine/"/>
      <url>2019/03/18/valine/</url>
      
        <content type="html"><![CDATA[<p>给Jekyll添加Valine评论系统</p><a id="more"></a><p>一直想给博客配置一款简洁的评论系统，但是没有发现合适的，最近倒腾一下Valine之后，发现效果还不错☺️  </p><p>详情请访问官网：<a href="https://valine.js.org/">https://valine.js.org</a>  </p><p>这个评论系统是基于LeanCloud的，对Jekyll的博客是支持的，官网网址：<a href="https://leancloud.cn/">https://leancloud.cn</a>  </p><h4 id="获取-APP-ID-和-APP-KEY"><a href="#获取-APP-ID-和-APP-KEY" class="headerlink" title="获取 APP ID 和 APP KEY"></a>获取 APP ID 和 APP KEY</h4><p>需要注册登录LeanCloud然后创建应用获取  </p><ol><li><p><a href="https://leancloud.cn/dashboard/login.html#/signup">点击这里登录或注册Leancloud</a></p></li><li><p>然后<a href="https://leancloud.cn/dashboard/applist.html#/newapp">创建应用</a>  </p><p><img src="/images/valine/blog1.png" alt="blog">    </p></li><li><p>选择刚刚创建的<code>应用</code>&gt;<code>设置</code>&gt;<code>应用 Key</code>，然后你就能看到你的<code>APP ID</code>和<code>APP KEY</code>  </p><p><img src="/images/valine/blog2.png" alt="blog2">  </p></li><li><p>然后填写<code>应用</code>&gt;<code>设置</code>&gt;<code>安全设置</code>中的<code>Web 安全域名</code>  </p><p><img src="/images/valine/blog3.png" alt="blog3">  </p></li></ol><h4 id="在blog中添加valine评论系统"><a href="#在blog中添加valine评论系统" class="headerlink" title="在blog中添加valine评论系统"></a>在blog中添加valine评论系统</h4><blockquote><p>由于我使用的是<a href="https://github.com/Simpleyyt/jekyll-theme-next">jekyll-theme-next</a>, 所以可能在其他模板中不适用  </p></blockquote><h5 id="创建valine-html"><a href="#创建valine-html" class="headerlink" title="创建valine.html"></a>创建valine.html</h5><p>在 <code>/_includes/_third-party/comments</code>文件夹中添加一个文件<code>valine.html</code><br>在文件里添加代码：  </p><p><img src="/images/valine/blog6.png" alt="blog4">  </p><p>中间几行需要配置在_config.yml文件当中  </p><h5 id="添加-config-yml配置"><a href="#添加-config-yml配置" class="headerlink" title="添加_config.yml配置"></a>添加_config.yml配置</h5><p>将<code>app_id</code>，<code>app_key</code>， <code>placeholde</code>等信息添加到_config.yml配置当中<br>具体使用代码：  </p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">valine_comment:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="comment"># app_id</span></span><br><span class="line">  <span class="attr">leancloud_appid:</span> <span class="string">XXX</span></span><br><span class="line"><span class="comment"># app_key</span></span><br><span class="line">  <span class="attr">leancloud_appkey:</span> <span class="string">XXX</span></span><br><span class="line"><span class="comment"># placeholde</span></span><br><span class="line">  <span class="attr">placeholder:</span> <span class="string">“Just</span> <span class="string">go</span> <span class="string">go”</span></span><br></pre></td></tr></table></figure><h5 id="更改调用valine-html"><a href="#更改调用valine-html" class="headerlink" title="更改调用valine.html"></a>更改调用valine.html</h5><p>由于前面创建了valine.html，要jekyll博客能够运行这个页面的代码，使评论框显示在每篇文章的页面，需要在<code>/_includes/_third-party/comments/index.html</code>里面适当位置添加以下代码：  </p><p><img src="/images/valine/blog7.png" alt="blog5">  </p><p>此外，在<code>/_includes/_partials/comments.html</code>里面插入下列代码：  </p><p><img src="/images/valine/blog4.png" alt="blog6">  </p><p>最后生成的评论框如下：  </p><p><img src="/images/valine/blog5.png" alt="blog7"></p><p>感觉还不错！！  </p>]]></content>
      
      
      <categories>
          
          <category> Jekyll </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅识apply家族</title>
      <link href="2019/03/11/apply/"/>
      <url>2019/03/11/apply/</url>
      
        <content type="html"><![CDATA[<p>apply 家族函数</p><a id="more"></a><h3 id="apply函数"><a href="#apply函数" class="headerlink" title="apply函数"></a>apply函数</h3><p>apply函数是最常用的代替for循环的函数。apply函数可以对矩阵、数据框、数组(二维、多维)，按行或列进行循环计算，对子元素进行迭代，并把子元素以参数传递的形式给自定义的FUN函数中，并以返回计算结果。  </p><h4 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h4><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apply(X, MARGIN, FUN, <span class="keyword">...</span>)</span><br></pre></td></tr></table></figure><h4 id="参数列表"><a href="#参数列表" class="headerlink" title="参数列表"></a>参数列表</h4><p><code>X</code>：矩阵、数据框、数组  </p><p><code>MARGIN</code>：按行计算或按按列计算，1表示按行，2表示按列  </p><p><code>FUN</code>: 自定义函数  </p><p><code>…</code>: 自定义参数  </p><h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><ol><li>对于矩阵行求和    </li></ol>   <figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x&lt;-matrix(<span class="number">1</span>:<span class="number">12</span>,ncol=<span class="number">3</span>)</span><br><span class="line">apply(x,<span class="number">1</span>,sum)</span><br></pre></td></tr></table></figure>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## [1] 15 18 21 24</span><br></pre></td></tr></table></figure><ol start="2"><li>自定义函数的使用  </li></ol>   <figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#  生成data.frame  </span></span><br><span class="line">x &lt;- cbind(x1 = <span class="number">3</span>, x2 = c(<span class="number">4</span>:<span class="number">1</span>, <span class="number">2</span>:<span class="number">5</span>)); x</span><br></pre></td></tr></table></figure>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">##      x1 x2</span><br><span class="line">## [1,]  3  4</span><br><span class="line">## [2,]  3  3</span><br><span class="line">## [3,]  3  2</span><br><span class="line">## [4,]  3  1</span><br><span class="line">## [5,]  3  2</span><br><span class="line">## [6,]  3  3</span><br><span class="line">## [7,]  3  4</span><br><span class="line">## [8,]  3  5</span><br></pre></td></tr></table></figure>   <figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 自定义函数myFUN，第一个参数x为数据</span></span><br><span class="line"><span class="comment"># 第二、三个参数为自定义参数，可以通过apply的&#x27;...&#x27;进行传入。</span></span><br><span class="line">myFUN&lt;- <span class="keyword">function</span>(x, c1, c2) &#123;</span><br><span class="line">   c(sum(x[c1],<span class="number">1</span>), mean(x[c2])) </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 把数据框按行做循环，每行分别传递给myFUN函数，设置c1,c2对应myFUN的第二、三个参数</span></span><br><span class="line">apply(x,<span class="number">1</span>,myFUN,c1=<span class="string">&#x27;x1&#x27;</span>,c2=c(<span class="string">&#x27;x1&#x27;</span>,<span class="string">&#x27;x2&#x27;</span>))</span><br></pre></td></tr></table></figure>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">##      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8]</span><br><span class="line">## [1,]  4.0    4  4.0    4  4.0    4  4.0    4</span><br><span class="line">## [2,]  3.5    3  2.5    2  2.5    3  3.5    4</span><br></pre></td></tr></table></figure><h3 id="lapply函数"><a href="#lapply函数" class="headerlink" title="lapply函数"></a>lapply函数</h3><p>lapply函数是一个最基础循环操作函数之一。主要操作对象是list、data.frame，并返回和X长度同样的list结构作为结果集。  </p><h4 id="函数定义-1"><a href="#函数定义-1" class="headerlink" title="函数定义"></a>函数定义</h4><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lapply(X, FUN, <span class="keyword">...</span>)</span><br></pre></td></tr></table></figure><h4 id="参数列表-1"><a href="#参数列表-1" class="headerlink" title="参数列表"></a>参数列表</h4><p><code>X</code>：矩阵、数据框、数组<br><code>FUN</code>: 自定义函数<br><code>…</code>: 自定义参数  </p><h4 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h4><ol><li>对list进行操作  </li></ol>   <figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x &lt;- list(a = c(<span class="number">1</span>:<span class="number">3</span>), b = c(<span class="number">4</span>:<span class="number">6</span>), d = c(<span class="number">10</span>:<span class="number">20</span>))</span><br><span class="line">lapply(x, sum)</span><br></pre></td></tr></table></figure>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">## $a</span><br><span class="line">## [1] 6</span><br><span class="line">## </span><br><span class="line">## $b</span><br><span class="line">## [1] 15</span><br><span class="line">## </span><br><span class="line">## $d</span><br><span class="line">## [1] 165</span><br></pre></td></tr></table></figure><ol start="2"><li>对data.frame进行操作  </li></ol>   <figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x &lt;- data.frame(x1=<span class="number">3</span>, x2=c(<span class="number">2</span>:<span class="number">1</span>,<span class="number">4</span>:<span class="number">5</span>))</span><br><span class="line">lapply(x, sum)</span><br></pre></td></tr></table></figure>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">## $x1</span><br><span class="line">## [1] 12</span><br><span class="line">## </span><br><span class="line">## $x2</span><br><span class="line">## [1] 12</span><br></pre></td></tr></table></figure><h3 id="sapply函数"><a href="#sapply函数" class="headerlink" title="sapply函数"></a>sapply函数</h3><p>sapply函数是一个简化版的lapply，sapply增加了2个参数simplify和USE.NAMES，主要就是让输出看起来更友好，返回值为向量，而不是list对象。  </p><h4 id="函数定义-2"><a href="#函数定义-2" class="headerlink" title="函数定义"></a>函数定义</h4><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sapply(X, FUN, <span class="keyword">...</span>, simplify=<span class="literal">TRUE</span>, USE.NAMES = <span class="literal">TRUE</span>)</span><br></pre></td></tr></table></figure><h4 id="参数列表-2"><a href="#参数列表-2" class="headerlink" title="参数列表"></a>参数列表</h4><p><code>X</code>：矩阵、数据框、数组<br><code>FUN</code>: 自定义函数<br><code>…</code>: 自定义参数<br><code>simplify</code>：是否数组化，当值是array时，输出结果按数组进行分组<br><code>USE.NAMES</code>：如果X为字符串，TRUE设置字符串为数据名，FALSE不设置  </p><h4 id="应用-2"><a href="#应用-2" class="headerlink" title="应用"></a>应用</h4><p>对上面的数据框<code>x</code>进行操作：  </p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sapply(x, sum)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">## x1 x2 </span><br><span class="line">## 12 12</span><br></pre></td></tr></table></figure><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class(lapply(x, sum)) <span class="comment"># lapply返回list，sapply返回vector</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## [1] &quot;list&quot;</span><br></pre></td></tr></table></figure><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class(sapply(x, sum))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## [1] &quot;numeric&quot;</span><br></pre></td></tr></table></figure><h3 id="vapply函数"><a href="#vapply函数" class="headerlink" title="vapply函数"></a>vapply函数</h3><p>vapply类似于sapply，提供了FUN.VALUE参数，用来控制返回值的行名。  </p><h4 id="函数定义-3"><a href="#函数定义-3" class="headerlink" title="函数定义"></a>函数定义</h4><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vapply(X, FUN, FUN.VALUE, <span class="keyword">...</span>, USE.NAMES = <span class="literal">TRUE</span>)</span><br></pre></td></tr></table></figure><h4 id="参数列表-3"><a href="#参数列表-3" class="headerlink" title="参数列表"></a>参数列表</h4><p><code>X</code>：矩阵、数据框、数组<br><code>FUN</code>: 自定义函数<br><code>FUN.VALUE</code>：定义返回值的行名<br><code>…</code>: 自定义参数<br><code>USE.NAMES</code>：如果X为字符串，TRUE设置字符串为数据名，FALSE不设置  </p><h4 id="应用-3"><a href="#应用-3" class="headerlink" title="应用"></a>应用</h4><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x &lt;- data.frame(cbind(x1=<span class="number">3</span>, x2=c(<span class="number">2</span>:<span class="number">1</span>,<span class="number">4</span>:<span class="number">5</span>)))</span><br><span class="line">vapply(x,cumsum,FUN.VALUE = c(<span class="string">&#x27;a&#x27;</span>=<span class="number">0</span>,<span class="string">&#x27;b&#x27;</span>=<span class="number">0</span>,<span class="string">&#x27;c&#x27;</span>=<span class="number">0</span>,<span class="string">&#x27;d&#x27;</span>=<span class="number">0</span>)) <span class="comment">#注意FUN.VALUE的用法</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">##   x1 x2</span><br><span class="line">## a  3  2</span><br><span class="line">## b  6  3</span><br><span class="line">## c  9  7</span><br><span class="line">## d 12 12</span><br></pre></td></tr></table></figure><h3 id="mapply函数"><a href="#mapply函数" class="headerlink" title="mapply函数"></a>mapply函数</h3><p>相当于多参数版本的 sapply。第一次计算传入各组向量的第一个元素到FUN，进行结算得到结果；第二次传入各组向量的第二个元素，得到结果；第三次传入各组向量的第三个元素…以此类推。  </p><h4 id="函数定义-4"><a href="#函数定义-4" class="headerlink" title="函数定义"></a>函数定义</h4><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mapply(FUN, <span class="keyword">...</span>, MoreArgs = <span class="literal">NULL</span>, SIMPLIFY = <span class="literal">TRUE</span>,USE.NAMES = <span class="literal">TRUE</span>)</span><br></pre></td></tr></table></figure><h4 id="参数列表-4"><a href="#参数列表-4" class="headerlink" title="参数列表"></a>参数列表</h4><p>主要使用的参数有三个<br><code>FUN</code>: 自定义函数<br><code>FUN.VALUE</code>：定义返回值的行名<br><code>…</code>: 自定义参数  </p><h4 id="应用-4"><a href="#应用-4" class="headerlink" title="应用"></a>应用</h4><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mapply(rep, <span class="number">1</span>:<span class="number">4</span>, <span class="number">4</span>:<span class="number">1</span>) <span class="comment">#每一组参数都是对应的</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">## [[1]]</span><br><span class="line">## [1] 1 1 1 1</span><br><span class="line">## </span><br><span class="line">## [[2]]</span><br><span class="line">## [1] 2 2 2</span><br><span class="line">## </span><br><span class="line">## [[3]]</span><br><span class="line">## [1] 3 3</span><br><span class="line">## </span><br><span class="line">## [[4]]</span><br><span class="line">## [1] 4</span><br></pre></td></tr></table></figure><h3 id="tapply函数"><a href="#tapply函数" class="headerlink" title="tapply函数"></a>tapply函数</h3><p>tapply用于分组的循环计算，通过INDEX参数可以把数据集X进行分组，相当于group by的操作。  </p><h4 id="函数定义-5"><a href="#函数定义-5" class="headerlink" title="函数定义"></a>函数定义</h4><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tapply(X, INDEX, FUN = <span class="literal">NULL</span>, <span class="keyword">...</span>, simplify = <span class="literal">TRUE</span>)</span><br></pre></td></tr></table></figure><h4 id="参数列表-5"><a href="#参数列表-5" class="headerlink" title="参数列表"></a>参数列表</h4><p><code>X</code>：向量<br><code>INDEX</code>: 分组索引<br><code>FUN</code>: 自定义函数<br><code>…</code>: 接收多个数据<br><code>simplify</code>：是否数组化，当值array时，输出结果按数组进行分组  </p><h4 id="应用-5"><a href="#应用-5" class="headerlink" title="应用"></a>应用</h4><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对样本分组计数</span></span><br><span class="line">tapply(warpbreaks$breaks, warpbreaks[,-<span class="number">1</span>], sum)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">##     tension</span><br><span class="line">## wool   L   M   H</span><br><span class="line">##    A 401 216 221</span><br><span class="line">##    B 254 259 169</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> R </category>
          
      </categories>
      
      
        <tags>
            
            <tag> base </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tryCatch抓取错误</title>
      <link href="2019/03/06/trycatch/"/>
      <url>2019/03/06/trycatch/</url>
      
        <content type="html"><![CDATA[<a id="more"></a>  <h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在使用R进行循环操作时，出现错误，为了对错误进行分析，使用<code>tryCatch()</code>函数抓取处理错误  </p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>tryCatch常用的三种用法:  </p><h3 id="抓取错误"><a href="#抓取错误" class="headerlink" title="抓取错误"></a>抓取错误</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">tryCatch</span>(libray(test), error = <span class="keyword">function</span>(e)&#123;print(<span class="string">&quot;出现错误&quot;</span>)&#125; )</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## [1] &quot;出现错误&quot;</span><br></pre></td></tr></table></figure><p>释义：当加载<code>test</code>包时，出现错误，执行<code>error</code>函数  </p><blockquote><p>这里很适合在循环中出现错误的情况，可以对错误的循环结果进行赋值  </p></blockquote><h3 id="抓取警告和错误"><a href="#抓取警告和错误" class="headerlink" title="抓取警告和错误"></a>抓取警告和错误</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">tryCatch</span>(<span class="keyword">stop</span>(<span class="string">&quot;test&quot;</span>), <span class="keyword">warning</span> = <span class="keyword">function</span>(w)&#123;print(<span class="string">&quot;出现警告&quot;</span>)&#125;,</span><br><span class="line">          finally=&#123;</span><br><span class="line">            print(<span class="string">&quot;test&quot;</span>)</span><br><span class="line">          &#125;)</span><br><span class="line"><span class="comment">## Error in doTryCatch(return(expr), name, parentenv, handler) : test</span></span><br><span class="line"><span class="comment">## [1] &quot;test&quot;</span></span><br></pre></td></tr></table></figure><p>释义：执行语句出错，打印出错误，并执行<code>finally</code>函数  </p><blockquote><p>如果单独只有warning函数，则只是打印错误  </p></blockquote><h3 id="继续执行"><a href="#继续执行" class="headerlink" title="继续执行"></a>继续执行</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">tryCatch</span>(a = <span class="number">1</span>, finally=&#123;print(<span class="string">&quot;我是个测试&quot;</span>)&#125;)</span><br><span class="line"><span class="comment">## Error in tryCatchList(expr, classes, parentenv, handlers) : </span></span><br><span class="line"><span class="comment">##   argument &quot;expr&quot; is missing, with no default</span></span><br><span class="line"><span class="comment">## [1] &quot;我是个测试&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p><code>finally</code>函数无论错与对都会执行  </p></blockquote><h2 id="封装函数"><a href="#封装函数" class="headerlink" title="封装函数"></a>封装函数</h2><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">log_calculator &lt;- <span class="keyword">function</span>(x)&#123;</span><br><span class="line">    <span class="keyword">tryCatch</span>(</span><br><span class="line">        expr = &#123;</span><br><span class="line">            message(log(x))</span><br><span class="line">            message(<span class="string">&quot;Successfully executed the log(x) call.&quot;</span>)</span><br><span class="line">        &#125;,</span><br><span class="line">        error = <span class="keyword">function</span>(e)&#123;</span><br><span class="line">            message(<span class="string">&#x27;Caught an error!&#x27;</span>)</span><br><span class="line">            print(e)</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">warning</span> = <span class="keyword">function</span>(w)&#123;</span><br><span class="line">            message(<span class="string">&#x27;Caught an warning!&#x27;</span>)</span><br><span class="line">            print(w)</span><br><span class="line">        &#125;,</span><br><span class="line">        finally = &#123;</span><br><span class="line">            message(<span class="string">&#x27;All done, quitting.&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    )    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果如下：  </p><ul><li>如果<code>x</code>是有效数字，则<code>expr</code>和<code>finally</code>被执行：  </li></ul><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">log_calculator(-<span class="number">10</span>)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## Caught an warning!</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## &lt;simpleWarning in log(x): NaNs produced&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## All done, quitting.</span><br></pre></td></tr></table></figure><ul><li>如果<code>x</code>不是有效数字，则<code>expr</code>会报错，<code>warning</code>和<code>finally</code>被执行：  </li></ul><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">log_calculator(<span class="string">&quot;10&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## Caught an error!</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## &lt;simpleError in log(x): non-numeric argument to mathematical function&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## All done, quitting.</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> R </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据拆分与合并</title>
      <link href="2019/03/05/split-combn/"/>
      <url>2019/03/05/split-combn/</url>
      
        <content type="html"><![CDATA[<p>长宽数据格式的转换</p><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近在使用ggplot2绘制图像时，发现ggplot2对于数据的格式要求极为严格，对于不规则的数据进行转换十分头疼。经过一番研究发现一些函数可以简化数据的整形过程，收集如下：  </p><h2 id="数据的拆分与合并"><a href="#数据的拆分与合并" class="headerlink" title="数据的拆分与合并"></a>数据的拆分与合并</h2><p>ggplot2的输入数据需要是data.frame的形式，因此需要将list等进行融合整形，此时使用reshape2包的<code>melt()</code>函数进行操作就比较方便，此外还有几个相似功能的函数，具体使用如下：  </p><h3 id="reshape2"><a href="#reshape2" class="headerlink" title="reshape2"></a>reshape2</h3><p><code>melt()</code>—把宽格式数据转化成长格式  </p><p><code>cast()</code>—把长格式数据转化成宽格式【其中<code>dcast()</code>输出时返回一个数据框,<code>acast()</code>输出时返回一个向量/矩阵/数组】  </p><h4 id="具体用法"><a href="#具体用法" class="headerlink" title="具体用法"></a>具体用法</h4><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mydata</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">##   ID Time X1 X2</span><br><span class="line">## 1 NA    1  5 NA</span><br><span class="line">## 2  1    2  3  5</span><br><span class="line">## 3  2   NA NA  1</span><br><span class="line">## 4  2    1  2  4</span><br></pre></td></tr></table></figure><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">md &lt;- melt(mydata, id=c(<span class="string">&quot;ID&quot;</span>,<span class="string">&quot;Time&quot;</span>)) <span class="comment"># 等同于md &lt;- melt(mydata, id=1:2)</span></span><br><span class="line">md <span class="comment">#固定id，融合其他列</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">##   ID Time variable value</span><br><span class="line">## 1 NA    1       X1     5</span><br><span class="line">## 2  1    2       X1     3</span><br><span class="line">## 3  2   NA       X1    NA</span><br><span class="line">## 4  2    1       X1     2</span><br><span class="line">## 5 NA    1       X2    NA</span><br><span class="line">## 6  1    2       X2     5</span><br><span class="line">## 7  2   NA       X2     1</span><br><span class="line">## 8  2    1       X2     4</span><br></pre></td></tr></table></figure><blockquote><p>其实是固定id两列，将其他变量通过”variable”和”value”揉合在一起，结果产生了新的两列，一列是变量variable，指代是哪个揉合变量，另外一列是取值value，即变量对应的值  </p></blockquote><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">newmd&lt;- dcast(md, ID~variable, mean)</span><br><span class="line">newmd</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">##   ID X1  X2</span><br><span class="line">## 1  1  3 5.0</span><br><span class="line">## 2  2 NA 2.5</span><br><span class="line">## 3 NA  5  NA</span><br></pre></td></tr></table></figure><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">acast(md, ID~variable, mean)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">##    X1  X2</span><br><span class="line">## 1   3 5.0</span><br><span class="line">## 2  NA 2.5</span><br><span class="line">## NA  5  NA</span><br></pre></td></tr></table></figure><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">acast(md, ID~Time~variable)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">## , , X1</span><br><span class="line">## </span><br><span class="line">##     1  2 NA</span><br><span class="line">## 1  NA  3 NA</span><br><span class="line">## 2   2 NA NA</span><br><span class="line">## NA  5 NA NA</span><br><span class="line">## </span><br><span class="line">## , , X2</span><br><span class="line">## </span><br><span class="line">##     1  2 NA</span><br><span class="line">## 1  NA  5 NA</span><br><span class="line">## 2   4 NA  1</span><br><span class="line">## NA NA NA NA</span><br></pre></td></tr></table></figure><blockquote><p><code>cast()</code>函数处理的对象应该是<code>melt()</code>函数的结果  </p></blockquote><h3 id="其他函数"><a href="#其他函数" class="headerlink" title="其他函数"></a>其他函数</h3><h4 id="tidyr包"><a href="#tidyr包" class="headerlink" title="tidyr包"></a>tidyr包</h4><p><code>gather()</code>—-把宽度较大的数据转换成一个更长的形式，它类比于从reshape2包中<code>melt()</code>函数的功能  </p><p><code>spread()</code>—-把长的数据转换成一个更宽的形式，它类比于从reshape2包中<code>cast()</code>函数的功能  </p><h4 id="data-table包"><a href="#data-table包" class="headerlink" title="data.table包"></a>data.table包</h4><p><code>data.table</code>包中的<code>melt()</code> 和<code>dcast()</code> 是<code>reshape2</code>包里同名函数的扩展  </p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>数据拆分和合并的关系可以用《R语言实战》中的图形表示  </p><p><img src="/images/split-combn/reshape.png" alt="rashape">  </p>]]></content>
      
      
      <categories>
          
          <category> R </category>
          
      </categories>
      
      
        <tags>
            
            <tag> base </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>超几何分布和二项分布</title>
      <link href="2019/02/21/hypergeometric/"/>
      <url>2019/02/21/hypergeometric/</url>
      
        <content type="html"><![CDATA[<a id="more"></a>  <h2 id="超几何分布"><a href="#超几何分布" class="headerlink" title="超几何分布"></a>超几何分布</h2><p><strong>超几何分布</strong>是统计学上一种离散概率分布。它描述了由有限个物件中抽出<code>$n$</code> 个物件，成功抽出指定种类的物件的个数的概率（不归还）。  </p><p><strong>黑白球问题解释</strong>：例如共有<code>$N$</code>个球，其中<code>$m$</code>个白球。超几何分布描述了在该<code>$N$</code>个球中抽出<code>$n$</code>个，其中<code>$k$</code>个是白球的机率：<br>$$<br>f(k;n,m,N) = \frac{\binom{m} {k} \binom {N-m} {n-k}} {\binom {N} {n}}<br>$$<br>上式可如此理解：  </p><p><code>$\left( N \over n\right)$</code>表示所有在<code>$N$</code>个样本中抽出<code>$n$</code>个，而抽出的结果不一样的数目。  </p><p><code>$\left(m \over k\right)$</code>表示在<code>$m$</code>个样本中，抽出<code>$k$</code>个的方法数目。剩下来的样本都是及格的，而及格的样本有<code>$N-m$</code>个，剩下的抽法便有<code>$\left(&#123;N-m&#125; \over &#123;n-k&#125;\right)$</code>种。  </p><blockquote><p>若<code>$n=1$</code>，超几何分布还原为伯努利分布。若<code>$N$</code>接近 <code>$\infty$</code>，超几何分布可视为二项分布  </p></blockquote><h2 id="二项分布"><a href="#二项分布" class="headerlink" title="二项分布"></a>二项分布</h2><p>在概率论和统计学中，<strong>二项分布</strong>（英语：Binomial distribution）是<strong>n个独立的是/非试验中成功的次数的离散概率分布</strong>，其中每次试验的成功概率为<code>$p$</code>。这样的单次成功/失败试验又称为伯努利试验。实际上，当<code>$n=1$</code>时，二项分布就是伯努利分布。  </p><p><strong>具体解释：</strong>  </p><p>假设进行<code>$n$</code>次独立实验，每次实验“成功”的概率为<code>$p$</code>，失败的概率为<code>$1-p$</code>，所有成功的次数X就是一个参数为<code>$n$</code>和<code>$p$</code>的二项随机变量.数学公式定义为：<br>$$<br>p(k) = \binom {n} {k} * p^k * (1-p)^{n-k}<br>$$<br>二项分布公式基于伯努利分布得到，因为二项分布中每项实验都是独立的，因此每一次实验都是一次伯努利实验，在<code>$n$</code>次实验中，成功<code>$k$</code>次，排列方式有<code>$\left( &#123;n \over k&#125; \right)$</code>种，根据乘法原理，即可得到二项分布的公式。  </p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>超几何分布相当于连续抽取<code>$n$</code>次成功的概率（不放回抽样），二项分布是重复抽<code>$n$</code>次成功的概率（放回抽样）。  </p>]]></content>
      
      
      <categories>
          
          <category> statistics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> stats </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fisher精确检验</title>
      <link href="2019/02/19/fisher/"/>
      <url>2019/02/19/fisher/</url>
      
        <content type="html"><![CDATA[<a id="more"></a>  <h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>Fisher精确检验是用于分析列联表的统计显着性检验。虽然在实践中它适用于样本量较小的情况，但实际上它适用于所有样本量。它可以精确的计算出差异的显著性p值，而不是卡方检验得到的近似p值。  </p><h2 id="理论依据"><a href="#理论依据" class="headerlink" title="理论依据"></a>理论依据</h2><p>Fisher精确检验是基于超几何分布计算的，它分为两种，分别是单边检验（等同于超几何检验）和双边检验。  </p><blockquote><p>超几何分布是统计学上一种离散概率分布。它描述了由有限个物件中抽出n个物件，成功抽出指定种类的物件的次数（不归还）。称为超几何分布，是因为其形式与“超几何函数”的级数展式的系数有关。超几何分布的一个形象例子是：有N件物品，M件为次品，求取n件，其中有k件为次品的概率 = <code>$\frac &#123;\binom &#123;M&#125; &#123;k&#125; * \binom &#123;N-M&#125; &#123;n-k&#125;&#125; &#123;\binom &#123;N&#125; &#123;n&#125;&#125;$</code>   </p></blockquote><h2 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h2><p>在2*2列联表中，四格表周边和（即边际分布）计数固定不变的条件下，计算表内4个实际频数变动时的各种组合之概率Pi；再按照检验假设用单侧或双侧的累计概率P，依据所取的检验水准做出推断。  </p><h2 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h2><p>假如想要知道学习好坏是否和男女性别有关，那么现在随机抽出20个人，对应的统计列联表如下：  </p><table><thead><tr><th align="left"></th><th align="left">男</th><th align="left">女</th><th align="left">行总数</th></tr></thead><tbody><tr><td align="left"><strong>好</strong></td><td align="left">9</td><td align="left">3</td><td align="left"><strong>12</strong></td></tr><tr><td align="left"><strong>坏</strong></td><td align="left">1</td><td align="left">7</td><td align="left"><strong>8</strong></td></tr><tr><td align="left"><strong>列总数</strong></td><td align="left"><strong>10</strong></td><td align="left"><strong>10</strong></td><td align="left"><strong>20</strong></td></tr></tbody></table><p><strong>零假设</strong>：男女性别和学习好坏无关  </p><p>为了知道能否拒绝零假设，我们下面做个Fisher精确检验（单侧检验）  </p><p><strong>第一步</strong>：在零假设成立时（即性别与学习好坏无关），我们随机一抽就能抽出这20个样本的概率是（超几何概率）：<br>$$<br>p_1 = {\binom{12} {9}  \binom{8} {1} \over \binom{20} {10}} =  0.0095<br>$$<br><strong>第二步</strong>：如果行总数与列总数（又叫边际总数）不变，零假设不成立时的极端情况应该是，男生学习都好，那么我们可以得到新的列联表：  </p><table><thead><tr><th align="left">男</th><th align="left">女</th><th align="left">行总数</th><th></th></tr></thead><tbody><tr><td align="left"><strong>好</strong></td><td align="left">10</td><td align="left">2</td><td><strong>12</strong></td></tr><tr><td align="left"><strong>坏</strong></td><td align="left">0</td><td align="left">8</td><td><strong>8</strong></td></tr><tr><td align="left"><strong>列总数</strong></td><td align="left"><strong>10</strong></td><td align="left"><strong>10</strong></td><td><strong>20</strong></td></tr></tbody></table><p>这时，可以计算这个表格的超几何概率：<br>$$<br>p_2 = {\binom{12} {10}  \binom{8} {0} \over \binom{20} {10}} =  3.5723 \times 10^{-4}<br>$$<br>那么Fisher精确检验的P value就是两者加和，即<br>$$<br>p_1 + p_2 = 0.0099<br>$$<br>p值越小，我们越有信心拒绝零假设。如果我们以0.05为显著性水平判断值的话，我们可以认为，男生的学习更好  </p><blockquote><p>注意：以上例子计算的是单侧检验的结果，对于双侧结果，一般是说在所有四格表的组合当中，将概率小于或等于原四格表的概率相加，得到双侧概率（需要进一步验证这种说法）  </p></blockquote><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>Fisher精确检验是基于超几何分布检验的，相对于卡方检验来说，适用于小样本量的计算（卡方检验是通过大样本量来近似卡方分布求得近似的p值）  </p>]]></content>
      
      
      <categories>
          
          <category> statistics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> stats </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>富集分析</title>
      <link href="2019/02/18/enrichment/"/>
      <url>2019/02/18/enrichment/</url>
      
        <content type="html"><![CDATA[<a id="more"></a>  <h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>不管是转录组，还是芯片数据，或者其他有关基因的组学分析，每当数据分析到后面，要想得到结果，都躲不过这个富集分析。对基因功能进行富集分析, 就有可能发现在生物学过程中起关键作用的生物通路, 并且帮助理解生物学过程的分子机制。  </p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><strong>基因集</strong>，即 gene set，是一群具有某一特征的基因构成的集合，比如这些基因可能是出现在同一条通路（pathway）中，或者是具有相同的生物学功能。假如现在有一堆基因，如果想要知道这些基因是属于哪一条生物学通路，或者具有什么样的功能我们应该怎么办？这时候就需要使用到富集分析。  </p><h2 id="富集分析方法"><a href="#富集分析方法" class="headerlink" title="富集分析方法"></a>富集分析方法</h2><h3 id="ORA-Over-Representation-Analysis-：过表达分析【最常使用】"><a href="#ORA-Over-Representation-Analysis-：过表达分析【最常使用】" class="headerlink" title="ORA(Over Representation Analysis)：过表达分析【最常使用】"></a>ORA(Over Representation Analysis)：过表达分析【最常使用】</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>ORA其实可以通过黑白球问题来解释，假设现在有一堆球，包括m个黑球和n个白球；现在我从这一堆球中取出W个，那么最后要看的是这W个球中是黑色的多还是白色的多，即这W个球中主要富集黑色还是白色。  </p><blockquote><p>需要注意的是该方法假设样本或者说基因间是相互独立的，忽略了样本之间的相互联系  </p></blockquote><h4 id="常用统计学方法"><a href="#常用统计学方法" class="headerlink" title="常用统计学方法"></a>常用统计学方法</h4><p>超几何分布检验，二项分布检验，卡方检验，Fisher精确检验  </p><blockquote><p>实际上超几何分布是不放回的抽样，而二项分布是有放回的抽样，因此一般来说二项分布检验可以作为一个近似的估计  </p></blockquote><h3 id="FCS-Functional-Class-Scoring-功能集打分法"><a href="#FCS-Functional-Class-Scoring-功能集打分法" class="headerlink" title="FCS(Functional Class Scoring) 功能集打分法"></a>FCS(Functional Class Scoring) 功能集打分法</h3><p>该种方法已经不再强调单个基因的出现与否对富集造成的显著影响，而考虑到基因的表达等微量变化的叠加对于整个富集过程的影响。  </p><h4 id="具体方法"><a href="#具体方法" class="headerlink" title="具体方法"></a>具体方法</h4><p>要求的输入是一个排序的基因列表和一个基因集合，不需要设置阈值。计算单个基因表达水平的统计值，采用如衡量差异基因的ANOVA、Q-statistic、t检验、Z-score、信噪比，进行打分或排序，或者直接使用排序好的基因表达谱。同一通路上所有基因的表达水平统计值进行整合，汇集成单个通路水平的分数或统计值，采用基因水平统计的和、均值或中位数，Wilcoxon rank sum, Maxmean statistic, Kolmogorov-Smirnov statistic。对通路水平的显著性进行评估：利用重抽样(bootstrap)的统计学方法  </p><blockquote><p>该方法考虑了基因表达量的差异，相对于ORA来说更加细致化  </p></blockquote><h3 id="PT-Pathway-Topology-通路拓扑学"><a href="#PT-Pathway-Topology-通路拓扑学" class="headerlink" title="PT(Pathway Topology)通路拓扑学"></a>PT(Pathway Topology)通路拓扑学</h3><p>在通路的富集分析中，一般上游基因的表达水平改变要显著大于下游基因对整个通路的影响。PT方法就是把基因在通路中的位置，和其他基因的互作和调控关系结合在一起，评估每个基因对通路的贡献并算出权重，然后把权重整合到富集分析。  </p><h3 id="NT-Network-topology-网络拓扑学"><a href="#NT-Network-topology-网络拓扑学" class="headerlink" title="NT(Network topology)网络拓扑学"></a>NT(Network topology)网络拓扑学</h3><p>利用现有的全基因组范围的生物网络，提取数据库的基因相互作用关系（如：基因连接度、基因在网络中的距离），把基因的生物学属性整合到功能分析。利用网络拓扑结构来计算基因对特定生物通路的重要性并给予相应的权重，再利用传统的ORA 或 FCS 方法来评估特定生物通路的富集程度，如GANPA 和 LEGO。  </p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在富集分析中，使用最多的应该是Over Representation Analysis，常见的GO富集分析和KEGG富集都是基于Over Representation Analysis  </p>]]></content>
      
      
      <categories>
          
          <category> statistics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> stats </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>paste()和paste0()用法</title>
      <link href="2019/01/16/paste/"/>
      <url>2019/01/16/paste/</url>
      
        <content type="html"><![CDATA[<a id="more"></a>  <h3 id="函数用法"><a href="#函数用法" class="headerlink" title="函数用法"></a>函数用法</h3><p><strong>paste (…, sep = “ “, collapse = NULL)</strong>  </p><h3 id="用法详解"><a href="#用法详解" class="headerlink" title="用法详解"></a>用法详解</h3><p>其中<code>...</code>表示一个或多个R可以被转化为字符型的对象；参数<code>sep</code>表示分隔符，默认为空格；参数<code>collapse</code>可选，如果不指定值，那么函数paste的返回值是自变量之间通过sep指定的分隔符连接后得到的一个字符型向量；如果为其指定了特定的值，那么自变量连接后的字符型向量会再被连接成一个字符串，之间通过collapse的值分隔。  </p><h3 id="案例展示"><a href="#案例展示" class="headerlink" title="案例展示"></a>案例展示</h3><p>当不添加后置参数时，paste函数和as.character函数的效果是一样的：  </p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">paste(<span class="number">1</span>:<span class="number">12</span>)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">##  [1] &quot;1&quot;  &quot;2&quot;  &quot;3&quot;  &quot;4&quot;  &quot;5&quot;  &quot;6&quot;  &quot;7&quot;  &quot;8&quot;  &quot;9&quot;  &quot;10&quot; &quot;11&quot; &quot;12&quot;</span><br></pre></td></tr></table></figure><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">paste0(<span class="number">1</span>:<span class="number">12</span>) <span class="comment">#same</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">##  [1] &quot;1&quot;  &quot;2&quot;  &quot;3&quot;  &quot;4&quot;  &quot;5&quot;  &quot;6&quot;  &quot;7&quot;  &quot;8&quot;  &quot;9&quot;  &quot;10&quot; &quot;11&quot; &quot;12&quot;</span><br></pre></td></tr></table></figure><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">as.character(<span class="number">1</span>:<span class="number">12</span>) <span class="comment">#same</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">##  [1] &quot;1&quot;  &quot;2&quot;  &quot;3&quot;  &quot;4&quot;  &quot;5&quot;  &quot;6&quot;  &quot;7&quot;  &quot;8&quot;  &quot;9&quot;  &quot;10&quot; &quot;11&quot; &quot;12&quot;</span><br></pre></td></tr></table></figure><p>paste函数把它的自变量连成一个字符串，中间默认用空格分开，如：  </p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">paste(<span class="string">&quot;Hello&quot;</span>,<span class="string">&quot;world&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## [1] &quot;Hello world&quot;</span><br></pre></td></tr></table></figure><p>连接的自变量可以是向量，这时各对应元素连接起来，长度不相同时较短的向量被重复使用。如：  </p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">paste(<span class="string">&quot;A&quot;</span>, <span class="number">1</span>:<span class="number">6</span>, sep = <span class="string">&quot;&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## [1] &quot;A1&quot; &quot;A2&quot; &quot;A3&quot; &quot;A4&quot; &quot;A5&quot; &quot;A6&quot;</span><br></pre></td></tr></table></figure><p>如果希望返回的结果是一个元素，使用<code>paste(x,collapse)</code>来实现。  </p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">paste(letters[<span class="number">1</span>:<span class="number">6</span>],collapse=<span class="string">&quot;,&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## [1] &quot;a,b,c,d,e,f&quot;</span><br></pre></td></tr></table></figure><p>同时，可以结合<code>sep</code>参数来使用：  </p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">paste(<span class="string">&quot;A&quot;</span>, <span class="number">1</span>:<span class="number">6</span>, sep = <span class="string">&quot;&quot;</span>,collapse=<span class="string">&quot;,&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## [1] &quot;A1,A2,A3,A4,A5,A6&quot;</span><br></pre></td></tr></table></figure><blockquote><p>sep的优先级应该是高于collapse参数的，因此是先执行sep的操作，再执行collpase  </p></blockquote><h3 id="paste0-函数"><a href="#paste0-函数" class="headerlink" title="paste0()函数"></a>paste0()函数</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">paste (<span class="keyword">...</span>, sep = <span class="string">&quot; &quot;</span>, collapse = <span class="literal">NULL</span>)</span><br><span class="line">paste0(<span class="keyword">...</span>, collapse = <span class="literal">NULL</span>)</span><br></pre></td></tr></table></figure><p>两者对比不难发现：  </p><p><code>paste0(..., collapse)</code> 等同于 <code>paste(..., sep = &quot;&quot;, collapse)</code>, 效率更高些，其他用法相同  </p>]]></content>
      
      
      <categories>
          
          <category> R </category>
          
      </categories>
      
      
        <tags>
            
            <tag> base </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>绘图配色</title>
      <link href="2019/01/07/color/"/>
      <url>2019/01/07/color/</url>
      
        <content type="html"><![CDATA[<a id="more"></a>  <h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>本篇文章主要收集R语言绘图配色可能用到的一些方案，网站等信息，持续更新ing….  </p><h2 id="网站"><a href="#网站" class="headerlink" title="网站"></a>网站</h2><h3 id="colorbrewer"><a href="#colorbrewer" class="headerlink" title="colorbrewer"></a><a href="http://colorbrewer2.org/">colorbrewer</a></h3><p>这个网站中包含多种可视化主题，RColorBrewer包中的配色方案来源于此  </p><h3 id="R语言中的色彩和调色板"><a href="#R语言中的色彩和调色板" class="headerlink" title="R语言中的色彩和调色板"></a><a href="http://iccm.cc/colors-and-palettes-in-r-language/">R语言中的色彩和调色板</a></h3><p>该博文中介绍了介绍了几种常见的R的色彩配色  </p><h3 id="RGB颜色表"><a href="#RGB颜色表" class="headerlink" title="RGB颜色表"></a><a href="http://www.5tu.cn/colors/rgb-peisebiao.html">RGB颜色表</a></h3><p>提供了各种颜色对应的RGB和16色代码  </p><p>更新ing… …  </p>]]></content>
      
      
      <categories>
          
          <category> R </category>
          
      </categories>
      
      
        <tags>
            
            <tag> color </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>R的更新</title>
      <link href="2018/11/22/updateR/"/>
      <url>2018/11/22/updateR/</url>
      
        <content type="html"><![CDATA[<a id="more"></a>  <h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在windows中R和Rstudio的更新是非常头疼的问题，每次更新都需要把之前的版本删掉重新安装，甚是麻烦。所以一直在想是否有R包可以实现R的自动更新和配置。  </p><h3 id="R的更新"><a href="#R的更新" class="headerlink" title="R的更新"></a>R的更新</h3><p>目前R已经提供了<code>installr</code>包用于更新R版本及其相关的软件，目前这种方法只适合于Windows平台。  </p><h4 id="installr安装"><a href="#installr安装" class="headerlink" title="installr安装"></a><code>installr</code>安装</h4><p>目前支持镜像安装，或者从<code>github</code>安装：  </p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 镜像安装</span></span><br><span class="line">install.packages(<span class="string">&#x27;installr&#x27;</span>)  </span><br><span class="line"></span><br><span class="line"><span class="comment"># github安装</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">require</span>(<span class="string">&#x27;devtools&#x27;</span>)) install.packages(<span class="string">&#x27;devtools&#x27;</span>); <span class="comment"># make sure you have Rtools installed first! if not, then run:</span></span><br><span class="line"><span class="comment">#install.packages(&#x27;installr&#x27;)</span></span><br><span class="line"><span class="comment">#install.Rtools()</span></span><br><span class="line">devtools::install_github(<span class="string">&#x27;talgalili/installr&#x27;</span>)</span><br></pre></td></tr></table></figure><h4 id="安装更新"><a href="#安装更新" class="headerlink" title="安装更新"></a>安装更新</h4><p>直接运行<code>installr()</code>，就会出现下面的选项框，选择需要更新的内容即可  </p><div align = center>     <img src = "/images/updateR/updateR.png"></div><p>目前使用这种方法更新的下载速度比较慢，可能是由于镜像的原因，建议切换到清华的镜像  </p><p><strong>注意</strong>：使用此方法更新Rstudio时，需要在R下运行，如果在Rstudio下将不能完成安装。  </p>]]></content>
      
      
      <categories>
          
          <category> R </category>
          
      </categories>
      
      
        <tags>
            
            <tag> base </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown常用语法</title>
      <link href="2018/11/20/markdown/"/>
      <url>2018/11/20/markdown/</url>
      
        <content type="html"><![CDATA[<a id="more"></a>  <h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><ol><li><a href="#%E4%BB%80%E4%B9%88%E6%98%AFmarkdown">什么是Markdown</a></li><li><a href="#%E4%BA%9A%E4%BC%A6%C2%B7%E6%96%AF%E6%B2%83%E8%8C%A8%E7%9A%84%E4%BC%A0%E5%A5%87%E4%BA%BA%E7%94%9F">亚伦·斯沃茨的传奇人生</a></li><li><a href="#markdown%E7%9A%84%E4%BC%98%E7%82%B9">Markdown的优点</a></li><li><a href="#markdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95">Markdown常用语法</a></li><li><a href="#%E6%89%A9%E5%B1%95%E8%AF%AD%E6%B3%95">扩展语法</a>  </li></ol><h3 id="什么是Markdown"><a href="#什么是Markdown" class="headerlink" title="什么是Markdown"></a>什么是Markdown</h3><p><strong>Markdown</strong>是一种<a href="https://zh.wikipedia.org/wiki/%E8%BD%BB%E9%87%8F%E7%BA%A7%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80">轻量级标记语言</a>，创始人为<a href="https://zh.wikipedia.org/wiki/%E7%B4%84%E7%BF%B0%C2%B7%E6%A0%BC%E9%AD%AF%E4%BC%AF">约翰·格鲁伯</a>（英语：John Gruber）。它允许人们“使用易读易写的纯文本格式编写文档，然后转换成有效的<a href="https://zh.wikipedia.org/wiki/XHTML">XHTML</a>（或者<a href="https://zh.wikipedia.org/wiki/HTML">HTML</a>）文档”。作为一种小型标记语言，Markdown很容易阅读，也很容易使用普通的文本编辑器编辑。  </p><p><strong>Markdown</strong>也可以理解为将以MARKDOWN语法编写的语言转换成HTML内容的工具。  </p><h3 id="亚伦·斯沃茨的传奇人生"><a href="#亚伦·斯沃茨的传奇人生" class="headerlink" title="亚伦·斯沃茨的传奇人生"></a>亚伦·斯沃茨的传奇人生</h3><p><strong>Markdown</strong>是由<a href="http://www.aaronsw.com/"><strong>Aaron Swartz</strong></a>和<strong>John Gruber</strong>共同设计的，<strong>Aaron Swartz</strong>就是那位于2013年自杀,有着<strong>开挂</strong>一般传奇人生经历的美国程序员。死后也被追授入<a href="https://zh.wikipedia.org/wiki/%E7%B6%B2%E9%9A%9B%E7%B6%B2%E8%B7%AF%E5%90%8D%E4%BA%BA%E5%A0%82">互联网名人堂</a>。维基百科对他的评价是：<a href="https://zh.wikipedia.org/wiki/%E7%BE%8E%E5%9B%BD">美国</a><a href="https://zh.wikipedia.org/wiki/%E7%94%B5%E8%84%91%E7%A8%8B%E5%BA%8F%E5%91%98">计算机程序员</a>、<a href="https://zh.wikipedia.org/wiki/%E4%BC%81%E4%B8%9A%E5%AE%B6">企业家</a>、<a href="https://zh.wikipedia.org/wiki/%E4%BD%9C%E5%AE%B6">作家</a>、<a href="https://zh.wikipedia.org/w/index.php?title=%E6%94%BF%E6%B2%BB%E6%B4%BB%E5%8A%A8%E8%80%85&action=edit&redlink=1">政治活动者</a>和互联网<a href="https://zh.wikipedia.org/w/index.php?title=%E9%BB%91%E5%AE%A2%E4%B8%BB%E4%B9%89&action=edit&redlink=1">黑客主义者</a>  </p><p>他的一生足以让我们膜拜：  </p><ul><li>13岁时，斯沃茨赢得为创办“有用、有教育意义、协作而非商业的网站”的年轻人而设的<a href="https://zh.wikipedia.org/w/index.php?title=ArsDigita_Prize&action=edit&redlink=1">ArsDigita</a>奖。</li><li>14岁时，斯沃茨加入编写早期版本的<a href="https://zh.wikipedia.org/wiki/RSS">RSS</a>1.0版本的工作组。</li><li><strong>2004</strong>年入读<strong>斯坦福</strong>，2005年暑假之后就退学创业。。。</li><li><strong>2005</strong>年创建<a href="http://infogami.org/">Infogami</a>，之后与<a href="http://www.reddit.com/">Reddit</a>合并成为其合伙人，斯沃茨被给予公司联合创始人的头衔。</li><li>2008 年，斯沃茨创办了 Watchdog.net，“会咬人的优秀政府类网站”（”the good government site with teeth”），用于汇集政治人物相关的数据起来并进行数据可视化。此外，他最著名的项目之一是《DeadDrop》（之后更名为《<a href="https://zh.wikipedia.org/w/index.php?title=SecureDrop&action=edit&redlink=1">SecureDrop</a>》），一个致力于帮助记者和线人（<a href="https://zh.wikipedia.org/wiki/%E5%91%8A%E5%AF%86%E8%80%85">告密者</a>）安全沟通的平台。</li><li>2010年创立求进会（Demand Progress），积极参与禁止网络盗版法案（SOPA）活动，最终该提案被撤回。<ul><li><strong>2011</strong>年7月19日，因被控从MIT和JSTOR下载480万篇学术论文并以免费形式上传于网络被捕。</li><li><strong>2013</strong>年1月自杀身亡，死后仍然影响着世界各地的黑客。</li><li><strong>科里·多克托罗的评价</strong>：亚伦拥有无以伦比的政治洞见力、技术能力和处理人、事的智能。我认为他本可以彻底改变美国（及世界）政治。不过——他的遗产仍然可以在将来对政治做出影响。  </li></ul></li></ul><div align = center>    <img src = "/images/markdown/220px-Aaron_Swartz_profile.jpg"/></div>  <h3 id="Markdown的优点"><a href="#Markdown的优点" class="headerlink" title="Markdown的优点"></a>Markdown的优点</h3><ul><li>易读（看起来舒服）、易写（语法简单）、易更改<strong>纯文本</strong></li><li>与HTML兼容，是属于程序员的Word</li><li>排版方便</li><li>越来越多的网站支持Markdown。（主要还是写博客方便😜）  </li></ul><h3 id="Markdown常用语法"><a href="#Markdown常用语法" class="headerlink" title="Markdown常用语法"></a>Markdown常用语法</h3><h4 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h4><p>标题一般有两种形式：<br>1）使用<code>=</code>和<code>-</code>标记一级和二级标题。</p><blockquote><p>一级标题  </p><p><code>========= </code>  </p><p>二级标题  </p><p><code>---------</code>  </p></blockquote><p>效果：</p><blockquote><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2></blockquote><p>2）使用<code>#</code>，可表示1-6级标题。</p><blockquote><p><code># 一级标题</code> </p><p><code>## 二级标题</code>    </p><p><code>### 三级标题</code>  </p><p><code>#### 四级标题</code>  </p><p><code>##### 五级标题</code>  </p><p><code>###### 六级标题</code></p></blockquote><p>效果:</p><blockquote><h1 id="一级标题-1"><a href="#一级标题-1" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题-1"><a href="#二级标题-1" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6></blockquote><h4 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h4><p>Markdown的段落前后都要有空行，如果要段内强制换行，需要使用<strong>两个以上</strong><code>空格键</code>加上<code>回车键</code>  </p><h4 id="区块引用"><a href="#区块引用" class="headerlink" title="区块引用"></a>区块引用</h4><p>在段落的每行或者只在第一行使用符号<code>&gt;</code>,还可使用多个嵌套引用，如：</p><blockquote><p>&gt;区块引用<br>&gt;&gt; 嵌套引用</p></blockquote><p>效果：</p><blockquote><p>区块引用</p><blockquote><p>嵌套引用  </p></blockquote></blockquote><h4 id="插入代码块"><a href="#插入代码块" class="headerlink" title="插入代码块"></a>插入代码块</h4><p>代码区块的建立有两种方法：<br>1）在每行加上4个空格或者一个制表符，如：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello Markdown</span><br></pre></td></tr></table></figure><p><strong>注意</strong>:和普通段落之间需要单独保留空行。  </p><p>2）使用三个**```** 来作为代码开始的标志，如：</p><blockquote><p>```<br>Hello Markdown<br>```</p></blockquote><p>效果如下：  </p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello Markdown</span><br></pre></td></tr></table></figure><h4 id="黑体和斜体"><a href="#黑体和斜体" class="headerlink" title="黑体和斜体"></a>黑体和斜体</h4><p>在强调内容两侧分别加上<code>*</code>或者<code>_</code>，如：</p><blockquote><p>*斜体*，<em>斜体</em>    </p><p>*<em>粗体\</em>*，<strong>粗体</strong></p></blockquote><h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><p><strong>无序列表</strong><br>使用<code>·</code>、<code>+</code>、或<code>-</code>标记无序列表，如：    </p><blockquote><p>-（+*） 第一项  </p><p>-（+*） 第二项  </p><p>-（+*）第三项  </p></blockquote><p><strong>注意</strong>：标记后面最少有一个_空格_或_制表符_。若不在引用区块中，必须和前方段落之间存在空行。  </p><p>效果：  </p><blockquote><ul><li>第一项</li><li>第二项</li><li>第三项  </li></ul></blockquote><p>有序列表的标记方式是将上述的符号换成数字,并辅以<code>.</code>，如：  </p><blockquote><p>1 . 第一项<br>2 . 第二项<br>3 . 第三项      </p></blockquote><p>效果：  </p><blockquote><ol><li>第一项</li><li>第二项</li><li>第三项  </li></ol></blockquote><h4 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h4><p>分割线最常使用就是三个或以上<code>*</code>，还可以使用<code>-</code>和<code>_</code>。  </p><p><strong>注意</strong>： 第一二级标题会自带分割线  </p><h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><p>链接可以由两种形式生成：<strong>行内式</strong>和<strong>参考式</strong>。  </p><p><strong>行内式</strong>：  </p><blockquote><p> [**Aaron Swartz**](<a href="http://www.aaronsw.com//">http://www.aaronsw.com/\</a>)    </p></blockquote><p>效果：  </p><p><a href="http://www.aaronsw.com/"><strong>Aaron Swartz</strong></a>  </p><p><strong>参考式</strong>：<br>就是以参考的形式给出链接  </p><blockquote><p>[**Aaron Swartz**][1]  </p><p>[**亚伦·斯沃茨**][2]  </p></blockquote><p>效果：  </p><p><a href="http://www.aaronsw.com/"><strong>Aaron Swartz</strong></a><br><a href="http://www.aaronsw.com/"><strong>亚伦·斯沃茨</strong></a>  </p><h4 id="图像插入"><a href="#图像插入" class="headerlink" title="图像插入"></a>图像插入</h4><p>插入图片的语法和插入超链接的语法基本一致，只是在最前面多一个 <code>!</code>。也可分为行内式和参考式两种。   </p><blockquote><p>![亚伦·斯沃茨](<a href="https://upload.wikimedia.org/wikipedia/commons/thumb/0/06/Aaron_Swartz_profile.jpg/220px-Aaron_Swartz_profile.jpg/">https://upload.wikimedia.org/wikipedia/commons/thumb/0/06/Aaron_Swartz_profile.jpg/220px-Aaron_Swartz_profile.jpg\</a>)</p></blockquote><p>Markdown 不支持指定图片的显示大小，不过可以通过直接插入<code>&lt;img /&gt;</code>标签来指定相关属性。  </p><h4 id="字符转义"><a href="#字符转义" class="headerlink" title="字符转义"></a>字符转义</h4><p>反斜线（<code>\</code>）用于插入在 Markdown 语法中有特殊作用的字符。  </p><h4 id="行内代码块"><a href="#行内代码块" class="headerlink" title="行内代码块"></a>行内代码块</h4><p>起到标记作用。如：  </p><blockquote><p>`hello`</p></blockquote><p>效果：  </p><blockquote><p><code>hello</code>  </p></blockquote><h3 id="扩展语法"><a href="#扩展语法" class="headerlink" title="扩展语法"></a>扩展语法</h3><h4 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h4><p>使用<code>~~</code>表示  </p><blockquote><p>~<del>删除线</del>  </p></blockquote><p>效果：</p><blockquote><p><del>删除线</del></p></blockquote><h4 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h4><p>使用<code>|</code>表示表格纵向边界，表头和表内容用<code>-</code>隔开，并可用<code>:</code>进行对齐设置，两边都有<code>:</code>则表示居中，若不加<code>:</code>则默认左对齐。  </p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">| left | center | right |</span><br><span class="line">| :--- | :----: | ----: |</span><br><span class="line">| aaaa | bbbbbb | ccccc |</span><br><span class="line">| a    | b      | c     |</span><br></pre></td></tr></table></figure><p>效果如下：</p><table><thead><tr><th align="left">left</th><th align="left">center</th><th align="left">right</th></tr></thead><tbody><tr><td align="left">aaaa</td><td align="left">bbbbbb</td><td align="left">ccccc</td></tr><tr><td align="left">a</td><td align="left">b</td><td align="left">c</td></tr></tbody></table><p>表格中不仅可以加入字符，还可以是链接等信息。  </p>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>卡方检验</title>
      <link href="2018/11/12/chisq/"/>
      <url>2018/11/12/chisq/</url>
      
        <content type="html"><![CDATA[<a id="more"></a>  <h2 id="卡方检验"><a href="#卡方检验" class="headerlink" title="卡方检验"></a>卡方检验</h2><p>卡方检验(Chi-square test/Chi-Square Goodness-of-Fit Test)  </p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>卡方检验是一种非参数假设检验，主要用于比较两个分类变量的关联性分析，其根本思想就是在于比较理论频数和实际频数的吻合程度或拟合优度问题。  </p><p>它在分类资料统计推断中的应用，包括：两个率或两个构成比比较的卡方检验；多个率或多个构成比比较的卡方检验以及分类资料的相关分析等。  </p><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><h4 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h4><p>卡方检验是以χ2分布为基础的一种假设检验方法，它的原假设H0是：观察频数与期望频数没有差别。  </p><p>首先假设H0成立，基于此前提下计算出χ2值，它表示观察值与理论值之间的偏离程度。根据χ2分布及自由度可以确定在H0假设成立的情况下获得当前统计量及更极端情况的概率P。如果P值很小，说明观察值与理论值偏离程度太大，应当拒绝无效假设，表示比较资料之间有显著差异；否则就不能拒绝无效假设，尚不能认为样本所代表的实际情况和理论假设有差别。  </p><h4 id="卡方值的计算与意义"><a href="#卡方值的计算与意义" class="headerlink" title="卡方值的计算与意义"></a>卡方值的计算与意义</h4><p>对于χ2统计量的计算，最初是由英国统计学家Karl Pearson在1900年首次提出的，因此也称之为Pearson χ2，其计算公式为<br>$$<br>\chi^2=\sum \frac{(A-E)^2}{E}=\sum_{i=1}^k \frac{(A_i-E_i)^2}{E_i}=\sum_{i=1}^k \frac{(A_i-np_i)^2}{np_i}　　(i=1，2，3，…，k)<br>$$</p><blockquote><p>其中，Ai为i水平的观察频数，Ei为i水平的期望频数，n为总频数，pi为i水平的期望频率。i水平的期望频数Ei等于总频数n×i水平的期望概率pi，k为单元格数。当n比较大时，χ2统计量近似服从k-1(计算Ei时用到的参数个数)个自由度的卡方分布。  </p></blockquote><p>由卡方的计算公式可知，当观察频数与期望频数完全一致时，χ2值为0；观察频数与期望频数越接近，两者之间的差异越小，χ2值越小；反之，观察频数与期望频数差别越大，两者之间的差异越大，χ2值越大。换言之，大的χ2值表明观察频数远离期望频数，即表明远离假设。小的χ2值表明观察频数接近期望频数，接近假设。因此，χ2是观察频数与期望频数之间距离的一种度量指标，也是假设成立与否的度量指标。如果χ2值“小”，研究者就倾向于不拒绝H0；如果χ2值大，就倾向于拒绝H0。至于χ2在每个具体研究中究竟要大到什么程度才能拒绝H0，则要借助于卡方分布求出所对应的P值来确定。  </p><h4 id="样本量要求"><a href="#样本量要求" class="headerlink" title="样本量要求"></a>样本量要求</h4><p>卡方分布本身是连续型分布，但是在分类资料的统计分析中，显然频数只能以整数形式出现，因此计算出的统计量是非连续的。只有当样本量比较充足时，才可以忽略两者问的差异，否则将可能导致较大的偏差具体而言，一般认为对于卡方检验中的每一个单元格，要求其最小期望频数均大于1，且至少有4／5的单元格期望频数大于5，此时使用卡方分布计算出的概率值才是准确的。如果数据不符合要求，可以采用Fisher精确检验计算。  </p><h3 id="卡方检验类型"><a href="#卡方检验类型" class="headerlink" title="卡方检验类型"></a>卡方检验类型</h3><h4 id="四格表资料的卡方检验"><a href="#四格表资料的卡方检验" class="headerlink" title="四格表资料的卡方检验"></a>四格表资料的卡方检验</h4><p>四格表资料的卡方检验用于进行两个率或两个构成比的比较。  </p><p>(1) 公式  </p><p>若四格表资料四个格子的频数分别为a，b，c，d，则四格表资料卡方检验的卡方值=<br>$$<br>(ad-bc)^2 \times n/(a+b)(c+d)(a+c)(b+d)<br>$$<br>自由度v=(行数-1)(列数-1)  </p><p>(2)  应用条件  </p><p>要求样本含量应大于40且每个格子中的理论频数不应小于5。当样本含量大于40但理论频数有小于5的情况时卡方值需要校正，当样本含量小于40时只能用Fisher精确检验计算概率。  </p><h4 id="行×列表资料的卡方检验"><a href="#行×列表资料的卡方检验" class="headerlink" title="行×列表资料的卡方检验"></a>行×列表资料的卡方检验</h4><p>行×列表资料的卡方检验用于多个率或多个构成比的比较。  </p><p>(1) 公式    </p><p>r行c列表资料卡方检验的卡方值:<br>$$<br>n[(A_{11}/n_1n_1+A_{12}/n_1n_2+\cdots+A_{rc}/n_rn_c)-1]<br>$$<br>(2) 应用条件  </p><p>要求每个格子中的理论频数T均大于5或1&lt;T&lt;5的格子数不超过总格子数的1/5。当有T&lt;1或1&lt;T&lt;5的格子较多时，可采用并行并列、删行删列、增大样本含量的办法使其符合行×列表资料卡方检验的应用条件。  </p><h4 id="列联表资料的卡方检验"><a href="#列联表资料的卡方检验" class="headerlink" title="列联表资料的卡方检验"></a>列联表资料的卡方检验</h4><p>同一组对象，观察每一个个体对两种分类方法的表现，结果构成双向交叉排列的统计表就是列联表。  </p><h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><ul><li>检验某个连续变量的分布是否与某种理论分布相一致。  </li><li>检验某个分类变量各类的出现概率是否等于指定概率。  </li><li>检验某两个分类变量是否相互独立。(最常见到的）  </li><li>检验某两种方法的结果是否一致。  </li></ul><h3 id="应用条件"><a href="#应用条件" class="headerlink" title="应用条件"></a>应用条件</h3><ol><li>所有的理论数T≥5并且总样本量n≥40，用Pearson卡方进行检验。  </li><li>如果理论数T＜5但T≥1，并且1≥40，用连续性校正的卡方进行检验。  </li><li>如果有理论数T＜1或n＜40，则用Fisher’s检验。  </li></ol><hr><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p><a href="https://wiki.mbalib.com/wiki/%E5%8D%A1%E6%96%B9%E6%A3%80%E9%AA%8C">卡方检验-MBA智库百科</a>  </p>]]></content>
      
      
      <categories>
          
          <category> statistics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> stats </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>R语言代码规范</title>
      <link href="2018/11/05/r-format/"/>
      <url>2018/11/05/r-format/</url>
      
        <content type="html"><![CDATA[<a id="more"></a>  <p>R语言是一门主要用于统计计算和绘图的高级编程语言. 在使用R时，好的代码编写和注释规范，可以提高代码的可读性和工作效率. 然而，什么样的规范更有利于我们自己使用和第三方解读？在此，建议使用《来自Google的R语言编码风格指南》一文中推荐的代码写作风格，这个规则是由Google的R用户群体协同设计而成.</p><h2 id="概要-R编码风格约定"><a href="#概要-R编码风格约定" class="headerlink" title="概要: R编码风格约定"></a>概要: R编码风格约定</h2><ol><li><a href="#%E6%96%87%E4%BB%B6%E5%91%BD%E5%90%8D">文件命名</a>: 以 .R (大写) 结尾</li><li><a href="#%E6%A0%87%E8%AF%86%E7%AC%A6%E5%91%BD%E5%90%8D">标识符命名</a>: variable.name, FunctionName, kConstantName</li><li><a href="#%E5%8D%95%E8%A1%8C%E9%95%BF%E5%BA%A6">单行长度</a>: 不超过80个字符</li><li><a href="#%E7%BC%A9%E8%BF%9B">缩进</a>: 两个空格, 不使用制表符</li><li><a href="#%E7%A9%BA%E7%99%BD">空白</a></li><li><a href="#%E8%8A%B1%E6%8B%AC%E5%8F%B7">花括号</a>: 前括号不折行写, 后括号独占一行</li><li><a href="#%E8%B5%8B%E5%80%BC">赋值符号</a>: 使用 &lt;-, 而非 =</li><li><a href="#%E5%88%86%E5%8F%B7">分号</a>: 不要用</li><li><a href="#%E6%80%BB%E4%BD%93%E5%B8%83%E5%B1%80%E5%92%8C%E9%A1%BA%E5%BA%8F">总体布局和顺序</a></li><li><a href="#%E6%B3%A8%E9%87%8A%E5%87%86%E5%88%99">注释准则</a>: 所有注释以 # 开始, 后接一个空格; 行内注释需要在 # 前加两个空格</li><li><a href="#%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E8%B0%83%E7%94%A8">函数的定义和调用</a></li><li><a href="#%E5%87%BD%E6%95%B0%E6%96%87%E6%A1%A3">函数文档</a></li><li><a href="#%E7%A4%BA%E4%BE%8B%E5%87%BD%E6%95%B0">示例函数</a></li><li><a href="#TODO%E4%B9%A6%E5%86%99%E9%A3%8E%E6%A0%BC">TODO书写风格</a>: TODO(您的用户名)</li></ol><h3 id="1-表示和命名"><a href="#1-表示和命名" class="headerlink" title="1. 表示和命名"></a>1. 表示和命名</h3><h4 id="文件命名"><a href="#文件命名" class="headerlink" title="文件命名"></a>文件命名</h4><p>文件名应以 .R (大写) 结尾, 文件名本身要有意义.<br>如: <font color = "green">predict_ad_revenue.R</font></p><h4 id="标识符命名"><a href="#标识符命名" class="headerlink" title="标识符命名"></a>标识符命名</h4><p>在标识符中不要使用下划线 ( _ ) 或连字符 ( - ). 标识符应根据如下惯例命名. 变量名应使用点 (.) 分隔所有的小写字母或单词; 函数名首字母大写, 不用点分隔 (所含单词首字母大写); 常数命名规则同函数, 但需使用一个 k 开头.</p><ul><li>变量命名<br>正例: <font color = "green">avg.clicks</font><br>反例: <font color = "red">avg_Clicks , avgClicks</font></li><li>FunctionName<br>正例: <font color = "green">CalculateAvgClicks</font><br>反例: <font color = "red">calculate_avg_clicks , calculateAvgClicks</font><br>函数命名应为动词或动词性短语.</li></ul><p><em>例外: 当创建一个含类 (class) 属性的对象时, 函数名 (也是constructor) 和类名 (class) 应当匹配 (例如, lm).</em></p><ul><li><font color = "green">kConstantName</font></li></ul><h3 id="2-语法"><a href="#2-语法" class="headerlink" title="2. 语法"></a>2. 语法</h3><h4 id="单行长度"><a href="#单行长度" class="headerlink" title="单行长度"></a>单行长度</h4><p>最大单行长度为 80 个字符.</p><h4 id="缩进"><a href="#缩进" class="headerlink" title="缩进"></a>缩进</h4><p>使用两个空格来缩进代码. 永远不要使用制表符或混合使用二者.<br><em>例外: 当括号内发生折行时, 所折行与括号内的第一个字符对齐.</em></p><h4 id="空白"><a href="#空白" class="headerlink" title="空白"></a>空白</h4><p>在所有二元操作符 (=, +, -, &lt;-, 等等) 的两侧加上空格.<br><em>例外: 在函数调用中传递参数时 = 两边的空格可加可不加</em>.</p><p>不可在逗号前加空格, 逗号后总须加空格.</p><p>例如:  </p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tabPrior &lt;- table(df[df$daysFromOpt &lt; <span class="number">0</span>, <span class="string">&quot;campaignid&quot;</span>])</span><br><span class="line">        total &lt;- sum(x[, <span class="number">1</span>])</span><br><span class="line">        total &lt;- sum(x[<span class="number">1</span>, ])</span><br></pre></td></tr></table></figure><p>在前括号前加一个空格, 函数调用时除外.<br>例如：  </p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (debug)</span><br></pre></td></tr></table></figure><p>多加空格 (即, 在行内使用多于一个空格) 也是可以的, 如果这样做能够改善等号或箭头 (&lt;-) 的对齐效果.  </p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">plot(x    = xCoord,</span><br><span class="line">     y    = dataMat[, makeColName(metric, ptiles[<span class="number">1</span>], <span class="string">&quot;roiOpt&quot;</span>)],</span><br><span class="line">     ylim = ylim,</span><br><span class="line">     xlab = <span class="string">&quot;dates&quot;</span>,</span><br><span class="line">     ylab = metric,</span><br><span class="line">     main = (paste(metric, <span class="string">&quot; for 3 samples &quot;</span>, sep=<span class="string">&quot;&quot;</span>)))</span><br></pre></td></tr></table></figure><p>不要向圆括号或方括号中的代码两侧加入空格.<br><em>例外: 逗号后总须加空格.</em></p><p>以下写法就是错误的：  </p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( debug )  <span class="comment"># debug 的两边不要加空格</span></span><br><span class="line">x[<span class="number">1</span>,]  <span class="comment"># 需要在逗号后加一个空格</span></span><br></pre></td></tr></table></figure><h4 id="花括号"><a href="#花括号" class="headerlink" title="花括号"></a>花括号</h4><p><strong>前括号永远不应该独占一行; 后括号应当总是独占一行</strong>. 您可以在代码块只含单个语句时省略花括号; 但在处理这类单个语句时, 您必须 前后一致地 要么全部使用花括号, 或者全部不用花括号.</p><p>例如：  </p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (is.null(ylim)) &#123;</span><br><span class="line">  ylim &lt;- c(<span class="number">0</span>, <span class="number">0.06</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者：  </p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (is.null(ylim))</span><br><span class="line">  ylim &lt;- c(<span class="number">0</span>, <span class="number">0.06</span>)</span><br></pre></td></tr></table></figure><p>总在新起的一行开始书写代码块的主体。  </p><h4 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h4><p>使用 <code>&lt;-</code> 进行赋值, 不用<code> =</code> 赋值  </p><h4 id="分号"><a href="#分号" class="headerlink" title="分号"></a>分号</h4><p>不要以分号结束一行, 也不要利用分号在同一行放多于一个命令. (分号是毫无必要的, 并且为了与其他Google编码风格指南保持一致, 此处同样略去.)  </p><h3 id="3-代码组织"><a href="#3-代码组织" class="headerlink" title="3. 代码组织"></a>3. 代码组织</h3><h4 id="总体布局和顺序"><a href="#总体布局和顺序" class="headerlink" title="总体布局和顺序"></a>总体布局和顺序</h4><p>如果所有人都以相同顺序安排代码内容, 我们就可以更加轻松快速地阅读并理解他人的脚本了.  </p><ol><li>版权声明注释</li><li>作者信息注释</li><li>文件描述注释, 包括程序的用途, 输入和输出</li><li><font color = "green">source()</font> 和 <font color = "green">library()</font> 语句</li><li>函数定义</li><li>要执行的语句, 如果有的话 (例如, <font color = "green">print, plot</font>)<br>单元测试应在另一个名为 <font color = "green">原始的文件名_unittest.R</font> 的独立文件中进行  </li></ol><h4 id="注释准则"><a href="#注释准则" class="headerlink" title="注释准则"></a>注释准则</h4><p>注释您的代码. 整行注释应以 <code># </code>后接一个空格开始.  </p><p>行内短注释应在代码后接两个空格, <code>#</code>, 再接一个空格.  </p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Create histogram of frequency of campaigns by pct budget spent.</span></span><br><span class="line">    hist(df$pctSpent,</span><br><span class="line">    breaks = <span class="string">&quot;scott&quot;</span>,  <span class="comment"># method for choosing number of buckets</span></span><br><span class="line">    main   = <span class="string">&quot;Histogram: fraction budget spent by campaignid&quot;</span>,</span><br><span class="line">    xlab   = <span class="string">&quot;Fraction of budget spent&quot;</span>,</span><br><span class="line">    ylab   = <span class="string">&quot;Frequency (count of campaignids)&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="函数的定义和调用"><a href="#函数的定义和调用" class="headerlink" title="函数的定义和调用"></a>函数的定义和调用</h4><p><strong>函数定义应首先列出无默认值的参数, 然后再列出有默认值的参数.</strong>  </p><p>函数定义和函数调用中, 允许每行写多个参数; 折行只允许在赋值语句外进行.  </p><p>例如：  </p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PredictCTR &lt;- <span class="keyword">function</span>(query, property, numDays,</span><br><span class="line">    showPlot = <span class="literal">TRUE</span>)</span><br></pre></td></tr></table></figure><p>理想情况下, 单元测试应该充当函数调用的样例 (对于包中的程序来说).  </p><h4 id="函数文档"><a href="#函数文档" class="headerlink" title="函数文档"></a>函数文档</h4><p>函数在定义行下方都应当紧接一个注释区. 这些注释应当由如下内容组成: 此函数的一句话描述; 此函数的参数列表, 用 Args: 表示, 对每个参数的描述 (包括数据类型); 以及对于返回值的描述, 以 Returns: 表示. 这些注释应当描述得足够充分, 这样调用者无须阅读函数中的任何代码即可使用此函数.  </p><h4 id="示例函数"><a href="#示例函数" class="headerlink" title="示例函数"></a>示例函数</h4><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">CalculateSampleCovariance &lt;- <span class="keyword">function</span>(x, y, verbose = <span class="literal">TRUE</span>) &#123;</span><br><span class="line">        <span class="comment"># Computes the sample covariance between two vectors.</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        <span class="comment"># Args:</span></span><br><span class="line">        <span class="comment">#   x: One of two vectors whose sample covariance is to be calculated.</span></span><br><span class="line">        <span class="comment">#   y: The other vector. x and y must have the same length, greater than one,</span></span><br><span class="line">        <span class="comment">#      with no missing values.</span></span><br><span class="line">        <span class="comment">#   verbose: If TRUE, prints sample covariance; if not, not. Default is TRUE.</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        <span class="comment"># Returns:</span></span><br><span class="line">        <span class="comment">#   The sample covariance between x and y.</span></span><br><span class="line">        n &lt;- length(x)</span><br><span class="line">        <span class="comment"># Error handling</span></span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span> || n != length(y)) &#123;</span><br><span class="line">        <span class="keyword">stop</span>(<span class="string">&quot;Arguments x and y have invalid lengths: &quot;</span>,</span><br><span class="line">        length(x), <span class="string">&quot; and &quot;</span>, length(y), <span class="string">&quot;.&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">TRUE</span> %<span class="keyword">in</span>% is.na(x) || <span class="literal">TRUE</span> %<span class="keyword">in</span>% is.na(y)) &#123;</span><br><span class="line">        <span class="keyword">stop</span>(<span class="string">&quot; Arguments x and y must not have missing values.&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        covariance &lt;- var(x, y)</span><br><span class="line">        <span class="keyword">if</span> (verbose)</span><br><span class="line">        cat(<span class="string">&quot;Covariance = &quot;</span>, round(covariance, <span class="number">4</span>), <span class="string">&quot;.\n&quot;</span>, sep = <span class="string">&quot;&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span>(covariance)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h4 id="TODO书写风格"><a href="#TODO书写风格" class="headerlink" title="TODO书写风格"></a>TODO书写风格</h4><p>编码时通篇使用一种一致的风格来书写TODO.<br><font color = "green">TODO(您的用户名): 所要采取行动的明确描述</font>  </p><hr><p><strong>Reference：</strong>  </p><p><a href="https://nanx.me/rstyle/">来自Google的R语言编码风格指南</a>  </p>]]></content>
      
      
      <categories>
          
          <category> R </category>
          
      </categories>
      
      
        <tags>
            
            <tag> base </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>R for beginners学习笔记</title>
      <link href="2018/10/27/r-beginner/"/>
      <url>2018/10/27/r-beginner/</url>
      
        <content type="html"><![CDATA[<a id="more"></a>  <h2 id="R-for-beginners"><a href="#R-for-beginners" class="headerlink" title="R for beginners"></a><strong>R for beginners</strong></h2><h3 id="一、基本原理和概念"><a href="#一、基本原理和概念" class="headerlink" title="一、基本原理和概念"></a><strong>一、基本原理和概念</strong></h3><ol><li>R是一种<strong>解释型语言</strong>， 而不是<strong>编译语言</strong>， 也就意味着输入的命令能够直接被执行， 而不需要像一些语言要首先构成一个完整的程序形式(如C， Fortan, Pascal, . . . )。  </li><li>当R运行时， 所有变量， 数据， 函数及结果都以对象(<em>objects</em>)的形式存在计算机的活动内存中， 并冠有相应的名字代号。  </li><li><strong>命名规范：</strong>对象的名字必须是以一个字母开头(A{Z 或a{z), 中间可以包含字母， 数字(0{9)， 点(.)及下划线( ). 因为R对对象的名字区分大小写， 所以x 和X就可以代表两个完全不同的对象。  </li><li>函数ls的功能是显示所有在内存中的对象，如果只要显示出在名称中带有某个指定字符的对象， 则通过设定选项pattern 来实现。如：<code>ls(pat = &quot;m&quot;)</code>,会显示在名称中以<code>m</code>开头的对象  </li><li>运行函数ls.str()将会展示内存中所有对象的详细信息  </li><li>要在内存中删除某个对象， 可利用函数<code>rm</code>: 运行<code>rm(x)</code>将会删除对象<code>x</code>,运行<code>rm(x,y)</code> 将会删除对象<code>x</code>和<code>y</code>， 而运行<code>rm(list=ls())</code>则会删除内存中的所有对象. 在<code>ls() </code>函数中的一些选项同样也可以运用到<code>rm</code>中来， 以选择的删除一些对象， 如: <code>rm(list=ls(pat=”^m”))</code>。  </li></ol><h3 id="二、R的数据操作"><a href="#二、R的数据操作" class="headerlink" title="二、R的数据操作"></a><strong>二、R的数据操作</strong></h3><h4 id="1-对象"><a href="#1-对象" class="headerlink" title="1. 对象"></a><strong>1. 对象</strong></h4><ol><li>在R中，操作的内容称作对象(<em>objects</em>)，对象的刻画主要通过：1）名称和内容；2）<strong>属性</strong>  </li><li>所有的对象都有两个内在属性： <strong>类型</strong>和<strong>长度</strong>。 类型是对象元素的基本种类，共有四种： <code>数值型</code>， <code>字符型</code>， <code>复数型</code>和<code>逻辑型</code> ；长度是对象中元素的数目。对象的类型和长度可以分别通过函数mode和length得到。  </li><li>对象的类型是可以通过<code>as.something</code>这种形式的函数可以完成转换的。  </li><li>比较两个对象时，需要使用<code>identical</code>和<code>all.equal</code>函数，他们两者之间存在差别：<code>identical</code>比较数据的内在关系， 如果对象是严格相同的返回<code>TRUE</code>， 否则返回<code>FALSE</code>。 <code>all.equal</code>用来判断两个对象是否“ 近似相等” ， 返回结果为<code>TRUE</code>或者对二者差异的描述。 后一个函数在比较数值型变量时考虑到了计算过程中的近似。具体示例如下：  </li></ol><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.9</span> == (<span class="number">1</span> - <span class="number">0.1</span>)</span><br><span class="line">identical(<span class="number">0.9</span>, <span class="number">1</span> - <span class="number">0.1</span>)</span><br><span class="line">all.equal(<span class="number">0.9</span>, <span class="number">1</span> - <span class="number">0.1</span>)</span><br><span class="line"><span class="number">0.9</span> == (<span class="number">1.1</span> - <span class="number">0.2</span>)</span><br><span class="line">identical(<span class="number">0.9</span>, <span class="number">1.1</span> - <span class="number">0.2</span>)</span><br><span class="line">all.equal(<span class="number">0.9</span>, <span class="number">1.1</span> - <span class="number">0.2</span>)</span><br><span class="line">all.equal(<span class="number">0.9</span>, <span class="number">1.1</span> - <span class="number">0.2</span>, tolerance = <span class="number">1e-16</span>)</span><br></pre></td></tr></table></figure><h3 id="三、R绘图"><a href="#三、R绘图" class="headerlink" title="三、R绘图"></a><strong>三、R绘图</strong></h3><ol><li>有两种绘图函数： 高级绘图函数（<em>high-level plotting functions</em>） 创建一个新的图形， 低级绘图函数（<em>low-level plotting functions</em>） 在现存的图形上添加元素。 绘图参数（<em>graphical parameters</em>） 控制绘图选项， 可以使用缺省值或者用函数par修改。  </li><li>绘图设备的切换选择：  </li></ol><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dev.list() <span class="comment">#显示当前绘图设备列表</span></span><br><span class="line">dev.cur()  <span class="comment">#显示当前所在绘图设备</span></span><br><span class="line">dev.set()  <span class="comment">#切换绘图设备</span></span><br><span class="line">dev.off()  <span class="comment">#关闭某个绘图设备</span></span><br></pre></td></tr></table></figure><ol start="3"><li>图形设备面板的分割  <ul><li>函数<code>split.screen</code>分割当前的绘图设备；<code>erase.screen()</code>删除最后绘制的图形。  </li><li>函数<code>layout</code>把当前的图形窗口分割为多个部份， 图形将一次显示在各部分中。 它主要的自变量是一个元素都是整数值的矩阵， 元素指示子窗口（\sub-windows”） 的编号。如：<code>layout(matrix(1:4, 2, 2))</code>,把设备划分为4个相等的部分。<code>layout.show</code>查看创建的分割。  </li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> R </category>
          
      </categories>
      
      
        <tags>
            
            <tag> base </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROC曲线和AUC</title>
      <link href="2018/10/10/roc-auc/"/>
      <url>2018/10/10/roc-auc/</url>
      
        <content type="html"><![CDATA[<a id="more"></a>  <h2 id="ROC和AUC简介"><a href="#ROC和AUC简介" class="headerlink" title="ROC和AUC简介"></a>ROC和AUC简介</h2><p>ROC（Receiver Operating Characteristic）曲线和AUC常被用来评价一个二值分类器（binary classifier）的优劣，对两者的简单介绍见<a href="https://zh.wikipedia.org/wiki/ROC%E6%9B%B2%E7%BA%BF">wiki百科</a>这篇博文主要简单介绍ROC和AUC的特点，以及如何通过R语言绘制ROC曲线和计算AUC值。  </p><h3 id="ROC曲线意义"><a href="#ROC曲线意义" class="headerlink" title="ROC曲线意义"></a>ROC曲线意义</h3><p>在这里，我们只讨论二值分类的情况，即“非此即彼”。一般对于二分问题来说，预测分类的结果有四种情况：</p><ol><li><strong>真阳性（TP）</strong>：预测为正样本，真实也是正样本。</li><li><strong>伪阳性（FP）</strong>：预测为正样本，而真实是负样本。</li><li><strong>真阴性（TN）</strong>：预测为负样本，真实也是负样本。</li><li><strong>伪阴性（FN）</strong>：预测为负样本，而真实是正样本。<br>用列联表表示其结果，如下所示，1代表正样本，0代表负样本：  </li></ol><p><img src="/images/roc-auc/table.png"></p><p>在这里需要引入两个名词：<br><strong>真阳性率 (TPR, true positive rate)</strong> ：又称：命中率 (hit rate)、敏感度(sensitivity) TPR = TP / P = TP / (TP+FN)<br><strong>伪阳性率(FPR, false positive rate)</strong> ：又称：错误命中率，假警报率 (false alarm rate) FPR = FP / N = FP / (FP + TN)</p><p>给定一个<strong>二元分类</strong>模型和它的<strong>阈值</strong>，就能从所有样本的（阳性／阴性）真实值和预测值计算出一个 (X=FPR, Y=TPR) 座标点。如下图所示：  </p><p><img src="/images/roc-auc/Roccurves.png"></p><p>接下来，我们考虑ROC曲线图中的四个点和一条线。第一个点，(0,1)，即FPR=0, TPR=1，这意味着这是一个完美的分类器，它能够将所有的样本都正确分类。第二个点，(1,0)，即FPR=1，TPR=0，说明这个分类器完全无效能可言，将所有的样本都错误的分类。第三个点，(0,0)，即FPR=TPR=0，说明所有的样本全是负样本。类似的，第四个点（1,1），分类器实际上预测所有的样本都为正样本。经过以上的分析，我们可以发现ROC曲线越接近左上角，说明分类器的分类效能越好。</p><p>下面考虑ROC曲线图中的虚线y=x上的点。这条对角线上的点其实表示的是一个采用随机猜测策略的分类器的结果，例如(0.5,0.5)，表示该分类器随机对于一半的样本猜测其为正样本，另外一半的样本为负样本。  </p><h3 id="ROC曲线绘制原理"><a href="#ROC曲线绘制原理" class="headerlink" title="ROC曲线绘制原理"></a>ROC曲线绘制原理</h3><p>对于一个分类器来说，其特点是“<strong>概率输出</strong>”,即分类一个样本是根据这个样本有多大概率是正样本（或负样本）来确定的。因此当分类器模型的<strong>阈值</strong>变化时，样本的分类情况也会发生改变，每种阈值的设定会得出不同的FPR和TPR。将<strong>同一分类器模型每个阈值</strong>的 (FPR, TPR) 座标都画在ROC空间里，就成为特定模型的ROC曲线。  </p><p>假如我们已经得到了所有样本的概率输出（属于正样本的概率），现在的问题是如何改变“discrimination threashold”？我们根据每个测试样本属于正样本的概率值从大到小排序。下图是一个示例，图中共有20个测试样本，“Class”一栏表示每个测试样本真正的标签（p表示正样本，n表示负样本），“Score”表示每个测试样本属于正样本的概率  </p><p><img src="/images/roc-auc/score-ranking.png">  </p><p>我们从高到低，依次将“Score”值作为阈值threshold，当测试样本属于正样本的概率大于或等于这个threshold时，我们认为它为正样本，否则为负样本。举例来说，对于图中的第4个样本，其“Score”值为0.6，那么样本1，2，3，4都被认为是正样本，因为它们的“Score”值都大于等于0.6，而其他样本则都认为是负样本。每次选取一个不同的threshold，我们就可以得到一组FPR和TPR，即ROC曲线上的一点。这样一来，我们一共得到了20组FPR和TPR的值，将它们画在ROC曲线的结果如下图：  </p><p><img src="/images/roc-auc/roc-example.png"></p><p>当我们将threshold设置为1和0时，分别可以得到ROC曲线上的(0,0)和(1,1)两个点。将这些(FPR,TPR)对连接起来，就得到了ROC曲线。当threshold取值越多，ROC曲线越平滑。  </p><h3 id="AUC的意义"><a href="#AUC的意义" class="headerlink" title="AUC的意义"></a>AUC的意义</h3><p>AUC（Area Under Curve），又称为曲线下面积，其意义为随机抽取一个阳性样本和一个阴性样本，分类器正确判断阳性样本的值高于阴性样本的机率。<strong>AUC值越大，说明当前分类器分类的正确率越高，分类器模型也就越好。</strong>  </p><ul><li>AUC = 1，是完美分类器，采用这个预测模型时，存在至少一个阈值能得出完美预测。绝大多数预测的场合，不存在完美分类器。</li><li>0.5 &lt; AUC &lt; 1，优于随机猜测。这个分类器（模型）妥善设定阈值的话，能有预测价值。</li><li>AUC = 0.5，跟随机猜测一样（例：丢铜板），模型没有预测价值。</li><li>AUC &lt; 0.5，比随机猜测还差；但只要总是反预测而行，就优于随机猜测。  </li></ul><p>图形示例如下：  </p><p><img src="/images/roc-auc/Curvas.png"></p><hr><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="http://alexkong.net/2013/06/introduction-to-auc-and-roc/">ROC和AUC介绍以及如何计算AUC</a></li><li><a href="https://zh.wikipedia.org/wiki/ROC%E6%9B%B2%E7%BA%BF">ROC曲线- 维基百科，自由的百科全书</a>  </li></ul>]]></content>
      
      
      <categories>
          
          <category> statistics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ROC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>同一电脑配置多个Github账户</title>
      <link href="2018/09/25/more-github/"/>
      <url>2018/09/25/more-github/</url>
      
        <content type="html"><![CDATA[<a id="more"></a>  <h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>最近在使用github时发现自己日常的代码和博客是放在同一个账户上的，作为一个强迫症患者的我，自然是要再申请一个github账号托管博客:)  </p><p>But！！！当我设置完毕后，发现并不能连接到远端进行克隆。。。简直是坑爹啊~有木有！经过一番研究终于找到解决办法，故记录如下：  </p><h2 id="SSH协议"><a href="#SSH协议" class="headerlink" title="SSH协议"></a>SSH协议</h2><p>Secure Shell（缩写为 SSH），是创建在应用层和传输层基础上的安全协议。目前主要用于远程登录会话和其他网络服务。连接github时，我们需要生成配对的SSH公钥和密钥来连接远程仓库。而一对公钥密钥只能识别一个账户。也就是说，当你设置连接两个远端github仓库时，你需要生成两对公钥密钥来进行身份识别。  </p><h2 id="配置流程"><a href="#配置流程" class="headerlink" title="配置流程"></a>配置流程</h2><p>以Github来举例说明（<strong>服务器的地址都是github.com，也可以是不同的地址</strong>），如何配置多用户，多地址提交项目。假设当前有两个账号：一个Github的账号是A，另一个Github的账号是B  </p><h3 id="1-配置多个Git账户"><a href="#1-配置多个Git账户" class="headerlink" title="1. 配置多个Git账户"></a>1. 配置多个Git账户</h3><p>这里分两种情况：  </p><blockquote><ol><li>一个账户已经进行了配置，添加另外一个账户</li><li>同时配置两个git账户</li></ol></blockquote><p>假如之前你已经有账户进行了git的全局设置，那么首先需要解除git全局<code>用户名/邮箱</code>的设置  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">git config --global --<span class="built_in">unset</span> <span class="string">&quot;user.name&quot;</span></span><br><span class="line">git config --global --<span class="built_in">unset</span> <span class="string">&quot;user.email&quot;</span></span><br><span class="line">```   </span><br><span class="line">如果之前并未进行全局设置，则直接开始设置每个仓库独立的用户和邮箱  </span><br><span class="line">```shell</span><br><span class="line"><span class="comment">#设置第一个用户/邮箱</span></span><br><span class="line">git config user.email <span class="string">&quot;A@gmail.com&quot;</span></span><br><span class="line">git config user.name <span class="string">&quot;A&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#设置第二个用户/邮箱</span></span><br><span class="line">git config user.email <span class="string">&quot;B@163.com&quot;</span></span><br><span class="line">git config user.name <span class="string">&quot;B&quot;</span></span><br></pre></td></tr></table></figure><h3 id="2-创建密钥-公钥"><a href="#2-创建密钥-公钥" class="headerlink" title="2. 创建密钥/公钥"></a>2. 创建<code>密钥/公钥</code></h3><p>在进行单用户操作时我们只需要通过：  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -f -C <span class="string">&quot;yourmail@xxx.com&quot;</span></span><br></pre></td></tr></table></figure><p>命令直接产生相应的<code>密钥/公钥</code>，但是在多用户的情况下,直接产生两次<code>密钥/公钥</code>会将第一次产生的<code>密钥/公钥</code>覆盖掉。因此，进行多用户操作时，需要指定产生的密钥名称，避免覆盖。  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建A账户的密钥、公钥</span></span><br><span class="line">ssh-keygen -t rsa -f ~/.ssh/id_rsa_A -C <span class="string">&quot;A@gmail.com&quot;</span></span><br><span class="line">ssh-keygen -t rsa -f ~/.ssh/id_rsa_B -C <span class="string">&quot;B@163.com&quot;</span></span><br><span class="line">```  </span><br><span class="line">此时会在用户的`.ssh`文件夹下产生`id_rsa_A`、`id_rsa_A.pub`和`id_rsa_B`、`id_rsa_B.pub`两对`密钥/公钥`。  </span><br><span class="line"><span class="comment">##### 3. 设置config文件  </span></span><br><span class="line">在.ssh文件夹下创建config文件,配置不同的仓库指向不同的密钥文件。</span><br><span class="line">```shell</span><br><span class="line"><span class="comment"># A账号</span></span><br><span class="line">Host A <span class="comment">#host别名</span></span><br><span class="line">HostName github.com <span class="comment">#服务器域名</span></span><br><span class="line">User git <span class="comment">#A账号用户名</span></span><br><span class="line">IdentityFile ~/.ssh/id_rsa</span><br><span class="line"><span class="comment"># B账号</span></span><br><span class="line">Host B  <span class="comment">#host别名</span></span><br><span class="line">HostName github.com <span class="comment">#服务器域名</span></span><br><span class="line">User git <span class="comment">#B账号用户名</span></span><br><span class="line">IdentityFile ~/.ssh/id_rsa_x</span><br></pre></td></tr></table></figure><blockquote><p><strong>原理解析</strong><br>1.ssh 客户端是通过类似 <a href="mailto:git@github.com">git@github.com</a>:githubUserName/repoName.git ** 的地址来识别使用本地的哪个私钥的，地址中的 User 是@前面的git， Host 是@后面的github.com。<br>2.如果所有账号的 User 和 Host 都为 git 和 github.com，那么就只能使用一个私钥。所以要对User 和 Host 进行配置，让每个账号使用自己的 Host，即使用上面的别名来代替域名。<br>3.配置了别名之后，新的地址就是git@A:githubUserName/repName.git**（在添加远程仓库时使用）。这样 ssh 在连接时就可以区别不同的账号了。  </p></blockquote><h3 id="4-添加SSH公钥"><a href="#4-添加SSH公钥" class="headerlink" title="4. 添加SSH公钥"></a>4. 添加SSH公钥</h3><p>把相应的公钥添加到账户的SSH设置当中，这样git就可以识别不同的账户了。  </p><hr><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://www.jianshu.com/p/04e9a885c5c8">https://www.jianshu.com/p/04e9a885c5c8</a>   </p>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git与github的使用简介</title>
      <link href="2018/05/23/git-github/"/>
      <url>2018/05/23/git-github/</url>
      
        <content type="html"><![CDATA[<a id="more"></a>   <h2 id="Git的基本使用方法"><a href="#Git的基本使用方法" class="headerlink" title="Git的基本使用方法"></a>Git的基本使用方法</h2><h2 id="Git简介"><a href="#Git简介" class="headerlink" title="Git简介"></a>Git简介</h2><p>Git是一个功能强大的分布是版本控制系统，由linux系统的创始人Linus创建，用于优化管理linux源码。Git具有强大的分支管理能力，对于代码集成管理具有超越其他集中式版本控制系统的优势。  </p><h2 id="Git安装"><a href="#Git安装" class="headerlink" title="Git安装"></a>Git安装</h2><p>在windows上安装Git，只需要从Git官网下载<a href="https://git-scm.com/">安装程序</a>，按照默认选项安装即可。  </p><p>最终，安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash”，蹦出一个类似命令行窗口的东西，就说明Git安装成功！  </p><p>安装完成后需要进行一步设置，在Git Bash中输入命令行  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;Your Name&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;email@example.com&quot;</span></span><br></pre></td></tr></table></figure><p>因为Git是分布式版本控制系统，所以，每个电脑必须有自己的ID：你的名字和Email地址。  </p><p>注意<code>git config</code>命令的<code>--global</code>参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。  </p><h3 id="Git的基本原理"><a href="#Git的基本原理" class="headerlink" title="Git的基本原理"></a>Git的基本原理</h3><p>在Git中,主要有两部分组成：工作区和版本库，而版本库又分为暂存区和分支。  </p><p>当你创建编辑一个文件后，首先需要将文件从工作区添加到版本库的暂存区，然后再从暂存区提交的Git的分支系统上。  </p><blockquote><p>个人认为，从工作区到暂存区的过程相当于将文件的所有更改日志依次保存在暂存区，而从暂存区提交到Git分支的过程则是一次性提交所有的更改  </p></blockquote><h3 id="本地仓库的使用"><a href="#本地仓库的使用" class="headerlink" title="本地仓库的使用"></a>本地仓库的使用</h3><blockquote><p>版本库又名仓库，英文名repository，可以理解成一个文件夹,这个文件夹下的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。  </p></blockquote><h4 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h4><p>找合适的地方，创建一个空目录，创建并进入，一般不要用中文的目录名，容易出现问题.  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">makdir learngit</span><br><span class="line"><span class="built_in">cd</span> learngit</span><br></pre></td></tr></table></figure><h4 id="初始化仓库"><a href="#初始化仓库" class="headerlink" title="初始化仓库"></a>初始化仓库</h4><p><code>git init</code> 命令将这个目录变成可以管理的版本仓库（git repository）  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line">Initialized empty Git repository <span class="keyword">in</span> /home/deepin/learngit/.git/</span><br></pre></td></tr></table></figure><p>此时你已经创建了一个空的版本库，可以发现当前目录下多了一个.git目录，这个目录就是git用来跟踪管理版本仓库的，不要去手动修改。  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">deepin@deepin-PC:~/learngit$ ls -a</span><br><span class="line">.  ..  .git</span><br></pre></td></tr></table></figure><h4 id="添加文件到仓库"><a href="#添加文件到仓库" class="headerlink" title="添加文件到仓库"></a>添加文件到仓库</h4><p>把文件添加到版本库，如果没有任何提示信息则为成功添加  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add README.md</span><br></pre></td></tr></table></figure><p>把文件提交到版本库  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">&quot;this is a README.md file&quot;</span></span><br></pre></td></tr></table></figure><p>双引号中输入的是文件描述信息，是对此次文件提交的说明  </p><p>同样，你也可以一次提交多个文件  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git add file1.txt</span><br><span class="line">git add file2.txt</span><br><span class="line">git add file3.txt</span><br><span class="line">git commit -m <span class="string">&quot;add 3 files.&quot;</span></span><br></pre></td></tr></table></figure><h3 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h3><p>当你已经在本地创建了一个Git仓库后，又想在GitHub创建一个Git仓库，使两个仓库能够远程同步，以下操作可以帮你实现  </p><ol><li>首先需要在远端github账户中创建自己的仓库  </li><li>在本地使用git命令添加远程仓库  </li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin &lt;adress&gt; <span class="comment">#最后是远程仓库地址</span></span><br></pre></td></tr></table></figure><p>添加后，远程库的名字就是<code>origin</code>，这是Git默认的叫法，也可以改成别的，但是<code>origin</code>这个名字一看就知道是远程库  </p><ol start="3"><li>然后就可以向远端仓库<code>push</code>文件  </li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><p>这条命令实际上是把本地<code>master</code>分支推送到远程仓库上，使用<code>-u</code>参数Git不但会把本地的<code>master</code>分支内容推送的远程新的<code>master</code>分支，还会把本地的<code>maste</code>r分支和远程的<code>master</code>分支关联起来，在以后的推送或者拉取时就可以简化命令。  </p><h3 id="Git的基本命令"><a href="#Git的基本命令" class="headerlink" title="Git的基本命令"></a>Git的基本命令</h3><h4 id="添加文件"><a href="#添加文件" class="headerlink" title="添加文件"></a>添加文件</h4><ul><li>使用命令<code>git add &lt;file&gt;</code>，注意，可反复多次使用，添加多个文件；  </li><li>使用命令<code>git commit -m &lt;message&gt;</code> 提交文件到仓库，添加提交注释信息  </li></ul><h4 id="状态查看"><a href="#状态查看" class="headerlink" title="状态查看"></a>状态查看</h4><p><code>git status</code>查看repository的状态，<code>git diff</code>查看修改了哪些内容  </p><h4 id="文件修改"><a href="#文件修改" class="headerlink" title="文件修改"></a>文件修改</h4><ul><li><code>git status</code>可以查看当前版本库中文件的提交状态  </li><li><code>git rm</code>可以删除某一文件  </li></ul><h4 id="版本退回"><a href="#版本退回" class="headerlink" title="版本退回"></a>版本退回</h4><ul><li><code>git reset</code>命令可以使文件退回之前的版本或者从之前的版本回到修改后的版本  </li></ul><blockquote><p>在Git中，用<code>HEAD</code>表示当前版本，上一个版本就是<code>HEAD^</code>，上上一个版本就是<code>HEAD^^</code>，当然往上100个版本写100个^比较容易数不过来，所以写成<code>HEAD~100</code>。   </p></blockquote><ul><li><p><code>git log</code>命令可以查看提交历史，以便确定要回退到哪个版本。  </p></li><li><p><code>git reflog</code>可以查看命令历史，以便确定要回到未来的哪个版本。  </p><blockquote><p>回退到以前的版本A之后，用<code>git log</code>命令就找不到A之后的版本了，如果想回到之后的版本，需要<code>git reset --hard commitID</code>，但是如果不记得<code>commitID</code>,可以用<code>git reflog</code>，它记录了每一个命令  </p></blockquote></li></ul><h3 id="常用的git命令"><a href="#常用的git命令" class="headerlink" title="常用的git命令"></a>常用的git命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">git init <span class="comment">#使当前目录变成可以管理的版本仓库（git repository)</span></span><br><span class="line">git add filename <span class="comment">#将文件添加到版本仓库</span></span><br><span class="line">git commit -m <span class="string">&quot;description&quot;</span> <span class="comment">#把文件提交到仓库</span></span><br><span class="line">git status <span class="comment">#查看repository的状态</span></span><br><span class="line">git diff <span class="comment">#查看修改了哪些内容</span></span><br><span class="line">git <span class="built_in">log</span> <span class="comment">#查看提交日志</span></span><br><span class="line">git <span class="built_in">log</span> --pretty=oneline <span class="comment">#简洁地显示提交日志</span></span><br><span class="line">git reset --hard HEAD~&lt;3&gt; <span class="comment">#回退到某个版本，比如这里回退到第前3个版本</span></span><br><span class="line">git reset --hard &lt;commit ID&gt; <span class="comment">#回退到特定ID的版本</span></span><br><span class="line">git reflog <span class="comment">#记录了每个命令，可以用来查看每个操作的编号</span></span><br><span class="line">git checkout -b &lt;branch&gt; <span class="comment">#创建并切换分支</span></span><br><span class="line">git branch <span class="comment">#查看当前分支</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cox回归分析</title>
      <link href="2018/04/23/cox-regression/"/>
      <url>2018/04/23/cox-regression/</url>
      
        <content type="html"><![CDATA[<p>Cox回归分析是在生存分析中最常用的影响因素分析，回归模型的前提假设只有一个：分析的因素必须满足<strong>比例风险假设</strong>，即协变量不随时间的变化而变化。  </p><h2 id="Cox比例风险模型"><a href="#Cox比例风险模型" class="headerlink" title="Cox比例风险模型"></a>Cox比例风险模型</h2><p>Cox回归模型建模的主要对象是危险率（Hazard Rate），记作$h(t)$，它的基本形式：  </p><p><img src="/images/cox-regression/pic1.png">  </p><p>它表示已生存到时间$t$的观察对象在t时刻的瞬时发生事件的概率，值为非负数。当$Δt=1$时，此时风险函数表示的就是时刻t存活的个体在此后一个单位死亡概率。  </p><p>Cox回归的假设是$h$满足这样的分布：  </p><p><img src="/images/cox-regression/pic2.png">   </p><p>其中$h0(t)$我们不要去管它,，表示的是基线风险，即协变量为0时的风险率。对于两个对象，它们危险率的比值（Hazard Ratio）是和$h0(t)$无关的。    </p><p><img src="/images/cox-regression/pic3.png">  </p><p><strong>对于每一个因素，如果回归系数的检验检验p值小于给定阈值，那么它的回归系数如果为正，该因素为风险因素，否则为保护因素（不利因素）。当确定该因素确实影响生存之后，影响力的大小可以用HR（hazard ratio）来表示。HR表示该影响因素增加一个单位风险率相对于原来增加多少倍。</strong>  </p><p>总结起来就是：  </p><ul><li>P&lt;0.05，β&gt;0，HR&gt;1(95%CI &gt;1)，说明变量X增加时，危险率增加，即X是危险因素；  </li><li>P&lt;0.05,β&lt;0，HR&lt;1(95%CI &lt;1)，说明变量X增加时，危险率下降，即X是保护因素；  </li><li>P=0.05,β较大可能=0，HR较大可能=1，说明变量X增加时，危险率不变，即X是危险无关因素。  </li></ul><h2 id="比例风险的假设的检验"><a href="#比例风险的假设的检验" class="headerlink" title="比例风险的假设的检验"></a>比例风险的假设的检验</h2><p>该假设主要用于评估<strong>协变量是否可以用于cox风险回归模型。但是，一般都不需要进行评估。</strong>  </p><p>判断一个变量是否满足比例风险模型假设有以下三种方式：  </p><ul><li>如果协变量为类协变量（即category var），那么每组别的K-M生存曲线无交叉，则满足比例风险假设；  </li><li>以生存时间t为横轴，对数对数生存率ln[-ln(p)]为纵轴，绘制分类变量的每一组别的生存曲线，如果各组别对应的曲线直观上平行，则满足风险比例条件。  </li><li>对于连续型协变量，可将每个协变量与对数生存时间的交互项X*ln(t)放入回归模型中，如果该将互相项没有统计学意义，则满足风险比例假设，如：  </li></ul><p><img src="/images/cox-regression/pic4.png">   </p><p><strong>当分析按比例风险的假定条件不成立是，可采用两种方法来解决</strong>：  </p><ul><li>将这种不满足假定的协变量作为分层变量，然后再用其余变量进行多元Cox回归模型分析。（分层分析）  </li><li>使用其他的参数模型。  </li></ul><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol><li>年龄，作为连续变量，一般情况是默认服从比例风险假设的，可以直接进行回归分析。  </li><li>单因素分析一方面可初步筛选出可能与预后有关的因素；另一方面去除那些根本不可能相关的因素，以减少建立多元回归模型时的“压力”。  </li></ol>]]></content>
      
      
      <categories>
          
          <category> Survival </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cox </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
