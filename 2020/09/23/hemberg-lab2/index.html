<!DOCTYPE html>
<html lang="zh-CN">

  <head>
  <meta charset="utf-8">
  <meta name="author" content="zchengsite, 1451426471@qq.com" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  
  
  <title>Hemberg-lab单细胞转录组数据分析（二） | Hexo</title>

  
    <link rel="apple-touch-icon" href="/images/favicon.png">
    <link rel="icon" href="/images/favicon.png">
  

  <!-- Raleway-Font -->
  <link href="https://fonts.googleapis.com/css?family=Raleway&display=swap" rel="stylesheet">

  <!-- hexo site css -->
  
<link rel="stylesheet" href="/css/base.css">
<link rel="stylesheet" href="/iconfont/iconfont.css">
<link rel="stylesheet" href="/css/github-markdown.css">
<link rel="stylesheet" href="/css/highlight.css">


  <!-- jquery3.3.1 -->
  <script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>

  <!-- fancybox -->
  <link href="https://cdn.bootcss.com/fancybox/3.5.2/jquery.fancybox.min.css" rel="stylesheet">
  <script async src="https://cdn.bootcss.com/fancybox/3.5.2/jquery.fancybox.min.js"></script>
  
<script src="/js/fancybox.js"></script>


  

<meta name="generator" content="Hexo 5.2.0"><link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
<style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"] > svg a {
  fill: blue;
  stroke: blue;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style></head>


  <body>
    <div id="app">
      <div class="header">
  <div class="avatar">
    <a href="/">
      <!-- 头像取消懒加载，添加no-lazy -->
      
        <img src="/images/mooner.jpg" alt="">
      
    </a>
    <div class="nickname"><a href="/">mooner</a></div>
  </div>
  <div class="navbar">
    <ul>
      
        <li class="nav-item" data-path="/">
          <a href="/">主页</a>
        </li>
      
        <li class="nav-item" data-path="/archives/">
          <a href="/archives/">归档</a>
        </li>
      
        <li class="nav-item" data-path="/tags/">
          <a href="/tags/">标签</a>
        </li>
      
        <li class="nav-item" data-path="/about/">
          <a href="/about/">关于</a>
        </li>
      
    </ul>
  </div>
</div>


<script src="/js/activeNav.js"></script>



      <div class="flex-container">
        <!-- 文章详情页，展示文章具体内容，url形式：https://yoursite/文章标题/ -->
<!-- 同时为「标签tag」，「朋友friend」，「分类categories」，「关于about」页面的承载页面，具体展示取决于page.type -->



  

  

  

  
  <!-- 文章内容页 url形式：https://yoursite/文章标题/ -->
  <div class="container post-details" id="post-details">
    <div class="post-content">
      <div class="post-title">Hemberg-lab单细胞转录组数据分析（二）</div>
      <div class="post-attach">
        <span class="post-pubtime">
          <i class="iconfont icon-updatetime" title="更新时间"></i>
          2020-09-23
        </span>
        
              <span class="post-tags">
                <i class="iconfont icon-tags" title="标签"></i>
                
                <span class="span--tag">
                  <a href="/tags/SingleCell/" title="SingleCell">
                    <b>#</b> SingleCell
                  </a>
                </span>
                
              </span>
          
      </div>
      <div class="markdown-body">
        <h2 id="scrna-seq原始数据处理">scRNA-seq原始数据处理</h2>
<h3 id="fastqc">FastQC</h3>
<p>得到单细胞RNA-seq测序数据后，首先检查测序reads的质量。为了完成这个任务，我们使用的工具是FastQC。FastQC是一款质控工具，能对bulk RNA-seq和单细胞RNA-seq的原始数据进行质量控制 (<em>其他类型的高通量测序结果也适用</em>)。FastQC以原始测序reads为输入(fastq格式)，输出序列质量报告。复制粘贴下面的链接到你的浏览器进入FastQC官网：</p>
<p>https://www.bioinformatics.babraham.ac.uk/projects/fastqc/</p>
<p>这个网址包含下载和安装FastQC及示例报告文件的链接。向下滚动页面到<code>Example Reports</code>并点击<code>Good Illumina Data</code>，会看到高质量Illumina测序Reads的理想质控结果。</p>
<p>现在让我们自己来做一个FastQC报告。</p>
<p>我们可以从 https://www.ebi.ac.uk/arrayexpress/experiments/E-MTAB-2600/ 下载<code>ERR522959_1.fastq</code>和<code>ERR522959_2.fastq</code> 原始测序文件。</p>
<p>使用<code>less</code>命令查看数据</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">less Share/ERR522959_1.fastq</span><br><span class="line">less Share/ERR522959_2.fastq</span><br></pre></td></tr></table></figure>
<p>使用FastQC生成报告</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir fastqc_results</span><br><span class="line">fastqc -o fastqc_results Share/ERR522959_1.fastq Share/ERR522959_2.fastq</span><br></pre></td></tr></table></figure>
<p>命令执行完成后，可以得到四个文件—每端reads对应一个<code>zip</code>文件和一个<code>html</code>文件。</p>
<p>大概浏览一下文件，记住要看双端<code>reads</code>的报告！</p>
<h3 id="移除接头和低质量碱基">移除接头和低质量碱基</h3>
<p><code>TrimGalore!</code>工具是对<code>cutadapt</code>软件的封装，用于移除测序接头序列或测序序列末端低质量碱基。</p>
<p>鉴于上一步FastQC报告中有一些接头污染，因此需要去除接头部分。</p>
<p>现在让我们尝试用<code>Trim Galore!</code>去除那些麻烦的接头序列，去除接头后，最好再运行FastQC查看接头是否去除干净。</p>
<p>可以用下面的命令来去除<code>Nextera</code>序列接头：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p fastqc_trimmed_results</span><br><span class="line">trim_galore --nextera -o fastqc_trimmed_results Share/ERR522959_1.fastq Share/ERR522959_2.fastq</span><br></pre></td></tr></table></figure>
<p>记住为<code>trimmed reads</code>文件生成新的FastQC报告！在报告里应该可以看到你的reads的<code>Adaptor Content</code>结果为<code>PASS</code>了</p>
<p>现在已经生成了reads质量报告并实行了接头去除，下一步，我们会用<code>STAR</code> (STAR有soft-clip机制，理论上只要文库质量不太差，不进行质控也可以)和<code>Kallisto</code>把质控后的reads比对到参考转录组。</p>
<h3 id="文件格式">文件格式</h3>
<h4 id="fastq">FastQ</h4>
<p>FastQ是<code>scRNASeq</code>数据中最原始数据的格式。所有的<code>scRNA-seq</code>方案都会进行双端测序，根据文库构建方法不同，条形码序列 (barcodes)可能出现在测序的左端或右端序列。但是使用唯一分子标签 (UMIs)的测序方案会产生包含细胞和<code>UMI barcode</code>再加接头序列但没有转录本序列的<code>reads</code>。因此reads虽然是双端测序，但比对时按单端reads对待。</p>
<p>FastQ文件格式如下</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;ReadID</span><br><span class="line">READ SEQUENCE</span><br><span class="line">+</span><br><span class="line">SEQUENCING QUALITY SCORES</span><br></pre></td></tr></table></figure>
<h4 id="bam">BAM</h4>
<p>BAM文件是存储比对结果的标准有效的高度压缩的二进制格式，其文本格式<code>SAM</code>是直接可读的。BAM/SAM文件包含一个头部，记录样本准备、测序和比对的信息；后面是每个reads的比对结果，<code>tab</code>作为列分隔符。</p>
<p>比对行有下列标准格式：</p>
<ol type="1">
<li>QNAME：read编号（如果是UMI文库，通常包含UMI条形码）</li>
<li>FLAG：数字标记指示reads比对的”类型”，如reads是否比对上，是否为<code>properly paired</code>等，Picard网站可以在”类型”和对应的数字之间进行转换，有更详细阐述。</li>
<li>RNAME：参考序列编号（比如比对到的染色体名字）。</li>
<li>POS：最左边的比对位置。</li>
<li>MAPQ：比对质量</li>
<li>CIGAR：表示reads的匹配/不匹配部分 (可能包括soft-clipping)</li>
<li>RNEXT：mate/next reads比对到的参考序列编号</li>
<li>PNEXT：mate/next reads比对到的第一个碱基位置</li>
<li>TLEN：模板长度（read比对到的参考区域的长度）</li>
<li>SEQ：read序列信息</li>
<li>QUAL：read质量信息</li>
</ol>
<p>BAM/SAM文件可以用<code>samtools</code>互相转换。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 新版本samtools中-S选项忽略，不需要再加，会自己判断输入的是bam还是sam格式</span><br><span class="line">samtools view -S -b file.sam &gt; file.bam</span><br><span class="line"># -h:包含header</span><br><span class="line">samtools view -h file.bam &gt; file.sam</span><br></pre></td></tr></table></figure>
<p>一些测序服务机构会自动把测序reads比对到标准基因组并提供<code>BAM</code>或<code>CRAM</code>格式文件，通常这些基因组不会包含<code>ERCC</code>序列，继而不会有<code>ERCC reads</code>比对到<code>BAM/CRAM</code>文件中。为了量化<code>ERCCs</code>（或序列有任何其他遗传变异或外源表达需要考虑时），或者如果想使用不同于标准流程中的比对算法，那你需要把<code>BAM/CRAM</code>文件转回<code>FastQ</code>:</p>
<p><code>bedtools</code>可以把<code>BAM</code>文件转成<code>FastQ</code>，为了避免把比对到多个基因组位置的同一个reads转换为FASTQ中的多条reads，需要先把BAM文件按read名称排序，并使用Samtools删除次级比对 (<code>secondary alignments</code>)。此外Picard里也有把<code>BAM</code>转成<code>FastQ</code>文件的方法。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sort reads by name</span></span><br><span class="line">samtools sort -n original.bam -o sorted_by_name.bam</span><br><span class="line"><span class="comment"># remove secondary alignments</span></span><br><span class="line">samtools view -b -F 256 sorted_by_name.bam -o primary_alignment_only.bam</span><br><span class="line"><span class="comment"># convert to fastq</span></span><br><span class="line">bedtools bamtofastq -i primary_alignment_only.bam -fq read1.fq -fq2 read2.fq</span><br></pre></td></tr></table></figure>
<h4 id="cram">CRAM</h4>
<p>CRAM文件与BAM文件类似，只是header中包含比对用到的参考基因组的信息。这使得每个read中与参考基因组相同的碱基可以被进一步压缩。CRAM也支持一些有损数据压缩方式来进一步优化储存，CRAMs格式主要是Sanger/EBI测序机构在使用。</p>
<p>CRAM和BAM文件可以用最新一版的<code>samtools(&gt;=v1.0)</code>相互转换。然而这个转换需要预先下载并缓存参考基因组。可以从CRAM文件的头部元数据中获得参考基因组信息自行下载，具体按下面的操作进行转换：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> REF_CACHE=/path_to/cache_directory_for_reference_genome</span><br><span class="line">samtools view -b -h -T reference_genome.fasta file.cram -o file.bam</span><br><span class="line">samtools view -C -h -T reference_genome.fasta file.bam -o file.cram</span><br></pre></td></tr></table></figure>
<h4 id="手动查看文件">手动查看文件</h4>
<p>一些时候，需要自己查看文件，比如查看下文件的<code>header</code>信息是否正确。<code>less</code>和<code>more</code>可以用来在命令行查看任意大小文本文件 (<em>个人更常用<code>less</code></em>)。管道符<code>|</code>可以在多个命令之间传输数据，省却把中间数据存储多个拷贝的过程，既简洁又快速。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">less file.txt</span><br><span class="line">more file.txt</span><br><span class="line"><span class="comment"># counts the number of lines in file.txt</span></span><br><span class="line">wc -l file.txt</span><br><span class="line">samtools view -h file.[cram/bam] | more</span><br><span class="line"><span class="comment"># counts the number of lines in the samtools output</span></span><br><span class="line">samtools view -h file.[cram/bam] | wc -l</span><br></pre></td></tr></table></figure>
<p><strong>练习</strong></p>
<p>假如你已经有了一个小的<code>cram</code>格式文件：<code>EXAMPLE.cram</code></p>
<ul>
<li><em>任务1</em>：这个文件是怎么获得的？用了什么比对软件?基因组的版本是什么？（提示：检查头部文件）</li>
<li><em>任务2</em>: 有多少reads比对或没比对上？文件共有多少短序列？<code>secondary alignments</code>有多少？（提示：用FLAG）</li>
<li><em>任务3</em>：将CRAM格式转成Fastq文件。转换后的每条read都是只有一个拷贝吗？（转换后的文件命名为 <code>10cells_read1.fastq</code> <code>10cells_read2.fastq</code>）</li>
</ul>
<p>小技巧：如果运行某个软件的帮助命令卡住时，直接输入命令，看看有无提示信息？</p>
<p><strong>答案</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">samtools view -T 2000_reference.transcripts.fa -H EXAMPLE.cram | less</span><br><span class="line">samtools view -T 2000_reference.transcripts.fa -f 4 EXAMPLE.cram | wc -l <span class="comment"># unmapped</span></span><br><span class="line">samtools view -T 2000_reference.transcripts.fa -F 260 EXAMPLE.cram | wc -l <span class="comment"># mapped</span></span><br><span class="line">samtools view -T 2000_reference.transcripts.fa -F 256 EXAMPLE.cram | wc -l <span class="comment"># total</span></span><br><span class="line">samtools view -T 2000_reference.transcripts.fa -f 256 EXAMPLE.cram | wc -l <span class="comment"># secondary alignments</span></span><br><span class="line"></span><br><span class="line">samtools view -b -h -T 2000_reference.transcripts.fa EXAMPLE.cram -o EXAMPLE.bam</span><br><span class="line">samtools sort -n EXAMPLE.bam -o sorted_EXAMPLE.bam</span><br><span class="line">samtools view -b -F 256 sorted_EXAMPLE.bam -o primary_EXAMPLE.bam </span><br><span class="line"><span class="comment"># convert to fastq</span></span><br><span class="line">bedtools bamtofastq -i primary_EXAMPLE.bam -fq 10cells_read1.fq -fq2 10cells_read2.fq</span><br></pre></td></tr></table></figure>
<h4 id="基因组和基因注释fastagtf">基因组和基因注释（FASTA,GTF）</h4>
<p>为了进行序列比对，需要参考基因组和/或基因组注释文件（<code>GTF</code>格式或<code>GFF</code>格式）。模式生物的基因组可以从任何主要的数据库下载：Ensembl, NCBI,或者UCSC Genome Browser。</p>
<p>GTF文件有基因、转录本和外显子的注释,他们必定包含：</p>
<ol type="1">
<li>seq_id：序列的编号，一般为chr或scafold编号；</li>
<li>source: 注释的来源，一般为数据库或者注释的机构，如果未知，则用点<code>.</code>代替；</li>
<li>type: 注释信息的类型，比如Gene、cDNA、mRNA、CDS等;</li>
<li>start: 该基因或转录本在参考序列上的起始位置 (从1开始，包含);</li>
<li>end: 该基因或转录本在参考序列上的终止位置 (从1开始，包含);</li>
<li>score: 得分，数字，是注释信息可能性的说明，可以是序列相似性比对时的E-values值或者基因预测是的P-values值，<code>.</code>表示为空;</li>
<li>strand: 该基因或转录本位于参考序列的正链(+)或负链(-)上;</li>
<li>phase: 仅对注释类型为<code>CDS</code>有效，表示起始编码的位置，有效值为<code>0,1,2</code>。(对于编码蛋白质的CDS来说，本列指定下一个密码子开始的位置。每3个核苷酸翻译一个氨基酸，从0开始，CDS的起始位置，除以3，余数就是这个值，表示到达下一个密码子需要跳过的碱基个数。<code>0</code>表示该编码框的第一个密码子第一个碱基位于其5’末端；<code>1</code>表示该编码框的第一个密码子的第一个碱基位于该编码区外；<code>2</code>表示该编码框的第一个密码子的第一、二个碱基位于该编码区外；)；</li>
<li>attributes: 一个包含众多属性的列表，格式为<code>标签 值</code>(<code>tag value</code>)，以多个键值对组成的注释信息描述，键与值之间用`<code>(空格分割)，不同的键值用</code>;<code>隔开，如</code>gene_id “gene”; transcript_id “geneA.1”; database_id “0012”; modified_by “Damian”; duplicate 0`。</li>
</ol>
<p>根据我们的经验，Ensembl是最容易使用的，并且具有最大的注释集。NCBI往往更严格，仅包含高可信度的基因注释。而UCSC包含多个使用不同标准的基因注释。</p>
<p>如果你的实验系统含有非标准序列 (比如<code>ERCC spike-ins</code>)，那么这些序列必须加到基因组<code>fasta</code>和<code>gtf</code>上来定量它们的表达。另外，对CRISPR相关序列或其他过表达/报告载体也必须进行相同的操作。</p>
<p>为了获得最大的可用性和灵活性，我们建议为任何添加的非标准序列创建完整详细的<code>fasta</code>序列文件和<code>gtf</code>文件。</p>
<p>目前还没有标准化的方法来做到这一点。下面是我们写的一个<code>perl</code>脚本，可以把<code>ERCC</code>序列转成对应的<code>gtf</code>和<code>fasta</code>文件，以便附加到标准基因组中。如果要量化内含子reads时，您可能还需要更改<code>gtf</code>文件以处理内含子中的重复元件。任何脚本语言甚至是<code>awk</code>或一些文本编辑器都可以相对有效地完成这项任务，但它们超出了本次课程的范围。</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Converts the Annotation file from </span></span><br><span class="line"><span class="comment"># https://www.thermofisher.com/order/catalog/product/4456740 to </span></span><br><span class="line"><span class="comment"># gtf and fasta files that can be added to existing genome fasta &amp; gtf files.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">my</span> @FASTAlines = ();</span><br><span class="line"><span class="keyword">my</span> @GTFlines = ();</span><br><span class="line"><span class="keyword">open</span> (<span class="keyword">my</span> $ifh, <span class="string">&quot;ERCC_Controls_Annotation.txt&quot;</span>) <span class="keyword">or</span> <span class="keyword">die</span> $!;</span><br><span class="line">&lt;$ifh&gt;; <span class="comment">#header</span></span><br><span class="line"><span class="keyword">while</span> (&lt;$ifh&gt;) &#123;</span><br><span class="line">    <span class="comment"># Do all the important stuff</span></span><br><span class="line">    <span class="keyword">chomp</span>;</span><br><span class="line">    <span class="keyword">my</span> @record = <span class="keyword">split</span>(<span class="regexp">/\t/</span>);</span><br><span class="line">    <span class="keyword">my</span> $sequence = $record[<span class="number">4</span>];</span><br><span class="line">    $sequence =~ <span class="regexp">s/\s+//g</span>; <span class="comment"># get rid of any preceeding/tailing white space</span></span><br><span class="line">    $sequence = $sequence.<span class="string">&quot;NNNN&quot;</span>;</span><br><span class="line">    <span class="keyword">my</span> $name = $record[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">my</span> $genbank = $record[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">push</span>(@FASTAlines, <span class="string">&quot;&gt;$name\n$sequence\n&quot;</span>);</span><br><span class="line"><span class="comment"># is GTF 1 indexed or 0 indexed? -&gt; it is 1 indexed</span></span><br><span class="line"><span class="comment"># + or - strand?</span></span><br><span class="line">    <span class="keyword">push</span>(@GTFlines, <span class="string">&quot;$name\tERCC\tgene\t1\t&quot;</span>.(<span class="keyword">length</span>($sequence)-<span class="number">2</span>).<span class="string">&quot;\t.\t+\t.\tgene_id \&quot;$name-$genbank\&quot;; transcript_id \&quot;$name-$genbank\&quot;; exon_number \&quot;1\&quot;; gene_name \&quot;ERCC $name-$genbank\&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">push</span>(@GTFlines, <span class="string">&quot;$name\tERCC\ttranscript\t1\t&quot;</span>.(<span class="keyword">length</span>($sequence)-<span class="number">2</span>).<span class="string">&quot;\t.\t+\t.\tgene_id \&quot;$name-$genbank\&quot;; transcript_id \&quot;$name-$genbank\&quot;; exon_number \&quot;1\&quot;; gene_name \&quot;ERCC $name-$genbank\&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">push</span>(@GTFlines, <span class="string">&quot;$name\tERCC\texon\t1\t&quot;</span>.(<span class="keyword">length</span>($sequence)-<span class="number">2</span>).<span class="string">&quot;\t.\t+\t.\tgene_id \&quot;$name-$genbank\&quot;; transcript_id \&quot;$name-$genbank\&quot;; exon_number \&quot;1\&quot;; gene_name \&quot;ERCC $name-$genbank\&quot;\n&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">close</span>($ifh);</span><br><span class="line"></span><br><span class="line"><span class="comment"># Write output</span></span><br><span class="line"><span class="keyword">open</span>(<span class="keyword">my</span> $ofh, <span class="string">&quot;&gt;&quot;</span>, <span class="string">&quot;ERCC_Controls.fa&quot;</span>) <span class="keyword">or</span> <span class="keyword">die</span> $!;</span><br><span class="line"><span class="keyword">foreach</span> <span class="keyword">my</span> $line (@FASTAlines) &#123;</span><br><span class="line">    <span class="keyword">print</span> $ofh $line;</span><br><span class="line">&#125; <span class="keyword">close</span> ($ofh);</span><br><span class="line"></span><br><span class="line"><span class="keyword">open</span>($ofh, <span class="string">&quot;&gt;&quot;</span>, <span class="string">&quot;ERCC_Controls.gtf&quot;</span>) <span class="keyword">or</span> <span class="keyword">die</span> $!;</span><br><span class="line"><span class="keyword">foreach</span> <span class="keyword">my</span> $line (@GTFlines) &#123;</span><br><span class="line">    <span class="keyword">print</span> $ofh $line;</span><br><span class="line">&#125; <span class="keyword">close</span> ($ofh);</span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下面两个awk命令可以实现perl脚本的功能</span></span><br><span class="line"><span class="comment"># 如果是windows的文件，替换下末尾的换行符</span></span><br><span class="line">sed -i <span class="string">&#x27;s/^M//&#x27;</span> ERCC_Controls_Annotation.txt</span><br><span class="line"><span class="comment"># 转成FASTA序列</span></span><br><span class="line">awk <span class="string">&#x27;BEGIN&#123;OFS=FS=&quot;\t&quot;&#125;&#123;if(FNR&gt;1) print &quot;&gt;&quot;$1&quot;\n&quot;$NF&quot;NNNN&quot;&#125;&#x27;</span> ERCC_Controls_Annotation.txt &gt;ERCC.fa</span><br><span class="line"><span class="comment"># 转成GTF</span></span><br><span class="line">awk <span class="string">&#x27;BEGIN&#123;OFS=FS=&quot;\t&quot;&#125;&#123;if(FNR&gt;1) &#123;seq_len=length($NF)+2; attr=&quot;gene_id \&quot;&quot;$1&quot;-&quot;$2&quot;\&quot;; transcript_id \&quot;&quot;$1&quot;-&quot;$2&quot;\&quot;; exon_number \&quot;1\&quot;; gene_name \&quot;&quot;$1&quot;-&quot;$2&quot;\&quot;&quot;; print $1,&quot;ERCC&quot;,&quot;gene&quot;,1,seq_len,&quot;.&quot;,&quot;+&quot;,&quot;.&quot;,attr; print $1,&quot;ERCC&quot;,&quot;transcript&quot;,1,seq_len,&quot;.&quot;,&quot;+&quot;,&quot;.&quot;,attr; print $1,&quot;ERCC&quot;,&quot;exon&quot;,1,seq_len,&quot;.&quot;,&quot;+&quot;,&quot;.&quot;,attr;&#125;&#125;&#x27;</span> ERCC_Controls_Annotation.txt &gt;ERCC.gtf</span><br></pre></td></tr></table></figure>
<h3 id="测序文库拆分-demultiplexing">测序文库拆分 (Demultiplexing)</h3>
<p>文库拆分因使用的前期Protocol不同或构建的流程不同需要有对应的处理方式。我们认为最灵活可用的文库拆分工具是<a target="_blank" rel="noopener" href="https://github.com/sdparekh/zUMIs/wiki/Usage">zUMIs</a>，可以用来拆分和比对大部分基于UMI的建库方式。对于<code>Smartseq2</code>或其他双端全长转录本方案，数据通常已经拆分好了。例如GEO或ArrayExpress之类的公共数据存储库会要求小规模或<code>plate-based scRNASeq</code>数据拆分好再上传，并且很多测序服务商提供的数据都是自动拆分好的。如果使用的分析流程依赖于拆分好的数据但测序服务商提供的数据没有拆分时就需要自己拆分。因为不同的建库方案引入的<code>barcode</code>序列的长度和位置不同，通常都需要自己写脚本解决。</p>
<p>对于所有数据类型，”文库拆分”涉及从一端或双端短序列中识别和移除细胞条形码序列 (<code>cell barcode</code>)。如果提前知道加入的细胞条形码，比如数据来自基于PCR板的方案，只需要找到条形码并与条形码库作比对，归类于与之最相似的那个就可以 (根据条形码的设计，一般允许最多1-2个错配)。这些数据通常在比对之前先做拆分，从而可以并行比对，提高效率。</p>
<p>我们有公开可用 (&lt;&gt;)的 perl脚本，可以拆分任何<code>plate-based</code>的建库方案生成的数据，不管有没有<code>UMI</code>。操作如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># https://github.com/tallulandrews/scRNASeqPipeline</span></span><br><span class="line"><span class="comment"># perl 1_Flexible_UMI_Demultiplexing.pl read1.fq read2.fq b_structure index mismatch prefix\n&quot;;</span></span><br><span class="line"><span class="comment">#    print STDERR &quot;</span></span><br><span class="line"><span class="comment">#    read1.fq : barcode/umi containing read</span></span><br><span class="line"><span class="comment">#    read2.fq : non-barcode containing read</span></span><br><span class="line"><span class="comment">#    b_structure : a single string of the format C##U# or U#C## </span></span><br><span class="line"><span class="comment">#        where C## is the cell-barcode and U# is the UMI.</span></span><br><span class="line"><span class="comment">#        e.g. C10U4 = a 10bp cell barcode followed by a 4bp UMI</span></span><br><span class="line"><span class="comment">#    index : file containg a single column of expected cell-barcodes.</span></span><br><span class="line"><span class="comment">#        if equal to \&quot;UNKNOWN\&quot; script will output read counts for each unique barcode.</span></span><br><span class="line"><span class="comment">#    mismatch : maximum number of permitted mismatches (recommend 2)</span></span><br><span class="line"><span class="comment">#    prefix : prefix for output fastq files.</span></span><br><span class="line">perl 1_Flexible_UMI_Demultiplexing.pl 10cells_read1.fq 10cells_read2.fq <span class="string">&quot;C12U8&quot;</span> 10cells_barcodes.txt 2 Ex</span><br></pre></td></tr></table></figure>
<p>运行过程输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">## </span><br><span class="line">##  Doesn&#39;t match any cell: 0</span><br><span class="line">##  Ambiguous: 0</span><br><span class="line">##  Exact Matches: 400</span><br><span class="line">##  Contain mismatches: 0</span><br><span class="line">##  Input Reads: 400</span><br><span class="line">##  Output Reads: 400</span><br><span class="line">## Barcode Structure: 12 bp CellID followed by 8 bp UMI</span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl utils/1_Flexible_FullTranscript_Demultiplexing.pl data/10cells_read1.fq data/10cells_read2.fq <span class="string">&quot;start&quot;</span> 12 data/10cells_barcodes.txt 2 Ex</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">## </span><br><span class="line">## Doesn&#39;t match any cell: 0</span><br><span class="line">## Ambiguous: 0</span><br><span class="line">## Exact Matches: 400</span><br><span class="line">## Contain Mismatches: 0</span><br><span class="line">## Input Reads: 400</span><br><span class="line">## Output Reads: 400</span><br></pre></td></tr></table></figure>
<p>对于包含<code>UMI</code>的数据，文库拆分包含把<code>UMI code</code>加到来源于基因区的序列的名字上。如果数据来源于<code>droplet-based protocol</code>或者<code>SeqWell</code>，实际加入的<code>barcode</code>序列的种类多于捕获到的细胞数时，为了避免生成特别多的文件，一般也把<code>cell-barcode</code>加到测序reads的名字后面。在这种情况下，文库拆分是在定量过程中进行的，有利于识别来源于完整细胞而不是背景噪声中的<code>cell-barcode</code>序列。</p>
<h4 id="鉴定含有细胞的液滴微孔">鉴定含有细胞的液滴/微孔</h4>
<p>液滴型scRNA-seq方法中只有一小部分的液滴包含珠状物和一个完整细胞。然而生物实验不会那么理想，有些RNA会从死细胞或破损细胞中漏出来。所以没有完整细胞的液滴有可能捕获周围环境游离出的少了RNA并且走完测序环节出现在最终测序结果中。液滴大小、扩增效率和测序环节中的波动会导致”背景”和真实细胞最终获得的文库大小变化很大，使得区分哪些文库来源于背景哪些来源于真实细胞变得复杂。</p>
<p>液滴型scRNA-seq方法中只有一小部分的液滴包含珠状物和一个完整细胞。然而生物实验不会那么理想，有些RNA会从死细胞或破损细胞中漏出来。所以没有完整细胞的液滴有可能捕获周围环境游离出的少了RNA并且走完测序环节出现在最终测序结果中。液滴大小、扩增效率和测序环节中的波动会导致”背景”和真实细胞最终获得的文库大小变化很大，使得区分哪些文库来源于背景哪些来源于真实细胞变得复杂。</p>
<p>大多数方法使用每个<code>barcode</code>对应的总分子数(如果是UMI)或总reads数的分布来寻找一个”break point”区分来自于真实细胞的较大的文库和来自于背景的较小的文库。下面加载一些包含大细胞和细胞的模拟数据实际操作下：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">umi_per_barcode &lt;- read.table(<span class="string">&quot;droplet_id_example_per_barcode.txt.gz&quot;</span>)</span><br><span class="line">truth &lt;- read.delim(<span class="string">&quot;droplet_id_example_truth.gz&quot;</span>, sep=<span class="string">&quot;,&quot;</span>)</span><br></pre></td></tr></table></figure>
<p><em>练习</em>: 有多少唯一的条形码被检测到？数据里多少来自真细胞？为了简化计算，写代码排除掉少于10个分子的条形码。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dim(umi_per_barcode)[<span class="number">1</span>]</span><br><span class="line">dim(truth)[<span class="number">1</span>]</span><br><span class="line">umi_per_barcode &lt;- umi_per_barcode[umi_per_barcode[,<span class="number">2</span>] &gt; <span class="number">10</span>,]</span><br></pre></td></tr></table></figure>
<p>一个找寻每个条形码对应的分子数突然下降的拐点的方法：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">barcode_rank &lt;- rank(-umi_per_barcode[,<span class="number">2</span>])</span><br><span class="line">plot(barcode_rank, umi_per_barcode[,<span class="number">2</span>], xlim=c(<span class="number">1</span>,<span class="number">8000</span>))</span><br></pre></td></tr></table></figure>
<p><img src="/images/lab2/unnamed-chunk-11-1.png" /></p>
<p>可以看到文库大小分布类似一条指数曲线，为了看的更清楚，对数据进行<code>log</code>转换。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">log_lib_size &lt;- log10(umi_per_barcode[,<span class="number">2</span>])</span><br><span class="line">plot(barcode_rank, log_lib_size, xlim=c(<span class="number">1</span>,<span class="number">8000</span>))</span><br></pre></td></tr></table></figure>
<p><img src="/images/lab2/unnamed-chunk-12-1.png" /></p>
<p>转换后，拐点更明显了，我们可以手动估计拐点的位置来区分背景噪音和真实细胞，但是用算法来识别要更精确，可重用性更强。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># inflection point</span></span><br><span class="line">o &lt;- order(barcode_rank)</span><br><span class="line">log_lib_size &lt;- log_lib_size[o]</span><br><span class="line">barcode_rank &lt;- barcode_rank[o]</span><br><span class="line"></span><br><span class="line">rawdiff &lt;- diff(log_lib_size)/diff(barcode_rank)</span><br><span class="line">inflection &lt;- which(rawdiff == min(rawdiff[<span class="number">100</span>:length(rawdiff)], na.rm=<span class="literal">TRUE</span>))</span><br><span class="line"></span><br><span class="line">plot(barcode_rank, log_lib_size, xlim=c(<span class="number">1</span>,<span class="number">8000</span>))</span><br><span class="line">abline(v=inflection, col=<span class="string">&quot;red&quot;</span>, lwd=<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/images/lab2/unnamed-chunk-13-1.png" /></p>
<p>另一种方法是构建混合模型，找出较高和较低分布相交的位置。但是数据可能不会像假定的分布那么好：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">set.seed(-<span class="number">92497</span>)</span><br><span class="line"><span class="comment"># mixture model</span></span><br><span class="line"><span class="keyword">require</span>(<span class="string">&quot;mixtools&quot;</span>)</span><br><span class="line"></span><br><span class="line">mix &lt;- normalmixEM(log_lib_size)</span><br><span class="line"><span class="comment">## number of iterations= 43</span></span><br><span class="line">plot(mix, which=<span class="number">2</span>, xlab2=<span class="string">&quot;log(mol per cell)&quot;</span>)</span><br><span class="line"></span><br><span class="line">p1 &lt;- dnorm(log_lib_size, mean=mix$mu[<span class="number">1</span>], sd=mix$sigma[<span class="number">1</span>])</span><br><span class="line">p2 &lt;- dnorm(log_lib_size, mean=mix$mu[<span class="number">2</span>], sd=mix$sigma[<span class="number">2</span>])</span><br><span class="line"><span class="keyword">if</span> (mix$mu[<span class="number">1</span>] &lt; mix$mu[<span class="number">2</span>]) &#123;</span><br><span class="line">    split &lt;- min(log_lib_size[p2 &gt; p1])</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    split &lt;- min(log_lib_size[p1 &gt; p2])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/lab2/unnamed-chunk-14-1.png" /></p>
<p>第三种方法，CellRanger假设真实细胞文库大小变化在10倍以内，用期望的细胞数目估计区间的分布。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">n_cells &lt;- length(truth[,<span class="number">1</span>])</span><br><span class="line"><span class="comment"># CellRanger</span></span><br><span class="line">totals &lt;- umi_per_barcode[,<span class="number">2</span>]</span><br><span class="line">totals &lt;- sort(totals, decreasing = <span class="literal">TRUE</span>)</span><br><span class="line"><span class="comment"># 99th percentile of top n_cells divided by 10</span></span><br><span class="line">thresh = totals[round(<span class="number">0.01</span>*n_cells)]/<span class="number">10</span></span><br><span class="line">plot(totals, xlim=c(<span class="number">1</span>,<span class="number">8000</span>))</span><br><span class="line">abline(h=thresh, col=<span class="string">&quot;red&quot;</span>, lwd=<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/images/lab2/unnamed-chunk-16-1.png" /></p>
<h3 id="使用star比对read">使用STAR比对read</h3>
<p>现在我们已经对测序原始数据进行了质控，获得了高质量的<code>Clean data</code>，下一步就是把它们比对到参考基因组。如果我们想定量基因表达或鉴定样本之间差异表达的基因，则通常需要某种形式的比对。</p>
<p>用于短序列比对的工具已经开发了很多，但今天我们主要涉及两个。第一个工具是STAR。对于测序数据中的每条reads，STAR尝试找到能与参考基因组中一个或多个位置匹配的最长可能序列。例如，在下图中，有一个短序列（蓝色），它跨越两个外显子和一个选择性剪接点（紫色）。STAR能够发现短序列的第一部分与第一外显子的序列匹配，而第二部分与第二外显子中的序列匹配。因为<code>STAR</code>能够用这种方式识别剪接事件，所以它被称为<code>splice aware</code>的比对工具</p>
<p><img src="/images/lab2/640.jpg" /></p>
<p>通常<code>STAR</code>把短序列比对到参考基因组时允许检测新的剪接事件或染色体重排事件。然而，STAR的一个问题是它需要大量的内存，尤其是参考基因组很大（例如老鼠和人类，大约需要30 G内存）的时候。为了加速今天的分析，我们将使用STAR把<code>reads</code>比对到只包含<code>2000</code>个转录本的参考转录组上。<strong>请注意</strong>，这<strong>不</strong>是常用或推荐的做法，只是考虑时间问题才这样做。我们通常建议比对到参考基因组 (但过程与此类似)。</p>
<p>执行STAR比对需要两个步骤。在第一步中，用户向STAR提供参考基因组序列（FASTA）和注释（GTF）,来创建基因组索引。第二步，STAR将用户的短序列数据比对到基因组索引。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 实际应用时比对到基因组</span></span><br><span class="line"><span class="comment"># 命令如下</span></span><br><span class="line">mkdir -p star_GRCh38</span><br><span class="line"><span class="comment"># --runThreadN 2: 指定使用2个线程</span></span><br><span class="line"><span class="comment"># --sjdbOverhang 100: 默认</span></span><br><span class="line">STAR --runMode genomeGenerate --runThreadN 2 --genomeDir star_GRCh38 \</span><br><span class="line">     --genomeFastaFiles GRCh38.fa --sjdbGTFfile GRCh38.gtf</span><br><span class="line"><span class="comment"># 输出文件如下，注意看下输出文件的大小，有无空文件，基因数是否对。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">ls -sh star_GRCh38</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 总用量 2.1G</span></span><br><span class="line"><span class="comment"># 4.0K chrLength.txt      368K exonInfo.tab          1.5G SAindex</span></span><br><span class="line"><span class="comment"># 4.0K chrNameLength.txt   24K geneInfo.tab          204K sjdbInfo.txt</span></span><br><span class="line"><span class="comment"># 4.0K chrName.txt         64M Genome                204K sjdbList.fromGTF.out.tab</span></span><br><span class="line"><span class="comment"># 4.0K chrStart.txt       4.0K genomeParameters.txt  204K sjdbList.out.tab</span></span><br><span class="line"><span class="comment"># 732K exonGeTrInfo.tab   516M SA                    224K transcriptInfo.tab</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># STAR解析后的基因数</span></span><br><span class="line">wc -l star_GRCh38/geneInfo.tab</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 原始GTF的基因数</span></span><br><span class="line">grep -cP <span class="string">&#x27;\tgene\t&#x27;</span> GRCh38.gtf</span><br></pre></td></tr></table></figure>
<p>现在完成了索引创建，执行比对步骤</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir results</span><br><span class="line">mkdir results/STAR</span><br><span class="line"></span><br><span class="line">STAR --runThreadN 4 --genomeDir indices/STAR --readFilesIn Share/ERR522959_1.fastq Share/ERR522959_2.fastq --outFileNamePrefix results/STAR/</span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p trt_N061011</span><br><span class="line"><span class="comment"># --runThreadN 4: 使用4个线程</span></span><br><span class="line"><span class="comment"># --readFilesIn: 输入文件，左端和右端</span></span><br><span class="line"><span class="comment"># --readFilesCommand zcat：gzip压缩，指定解压方式</span></span><br><span class="line"><span class="comment"># --genomeDir：基因组索引目录的位置</span></span><br><span class="line"><span class="comment"># -S: 指定输出文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 动物一般写 1000000，植物一般写5000</span></span><br><span class="line">max_intron_size=100000</span><br><span class="line"></span><br><span class="line"><span class="comment"># --genomeLoad LoadAndKeep : 共享内存</span></span><br><span class="line"><span class="comment"># 其他参数自己对着star的帮助手册看</span></span><br><span class="line">star_p=<span class="string">&quot; --outFilterType BySJout --outSAMattributes NH HI AS NM MD \</span></span><br><span class="line"><span class="string">       --outFilterMultimapNmax 20 --alignSJoverhangMin 8 --alignSJDBoverhangMin 1 \</span></span><br><span class="line"><span class="string">       --alignIntronMin 20 --alignIntronMax <span class="variable">$&#123;max_intron_size&#125;</span> \</span></span><br><span class="line"><span class="string">                --alignMatesGapMax <span class="variable">$&#123;max_intron_size&#125;</span> \</span></span><br><span class="line"><span class="string">                --outFilterMatchNminOverLread 0.66 --outFilterScoreMinOverLread 0.66 \</span></span><br><span class="line"><span class="string">                --winAnchorMultimapNmax 70 --seedSearchStartLmax 45 \</span></span><br><span class="line"><span class="string">                --outSAMattrIHstart 0 --outSAMstrandField intronMotif \</span></span><br><span class="line"><span class="string">                --genomeLoad LoadAndKeep --outReadsUnmapped Fastx \</span></span><br><span class="line"><span class="string">                --outSAMtype BAM Unsorted --quantMode TranscriptomeSAM GeneCounts&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># STAR比对单个样品                </span></span><br><span class="line">STAR --runMode alignReads --runThreadN 4 \</span><br><span class="line">        --readFilesIn trt_N061011_1.fq.gz trt_N061011_2.fq.gz \</span><br><span class="line">        --readFilesCommand zcat --genomeDir genome/star_GRCh38 \</span><br><span class="line">        --outFileNamePrefix trt_N061011/trt_N061011. <span class="variable">$&#123;star_p&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># STAR比对单个样品                </span></span><br><span class="line">STAR --runMode alignReads --runThreadN 4 \</span><br><span class="line">        --readFilesIn trt_N061011_1.fq.gz trt_N061011_2.fq.gz \</span><br><span class="line">        --readFilesCommand zcat --genomeDir genome/star_GRCh38 \</span><br><span class="line">        --outFileNamePrefix trt_N061011/trt_N061011. <span class="variable">$&#123;star_p&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Aug 03 11:44:27 ..... started STAR run</span></span><br><span class="line"><span class="comment"># Aug 03 11:44:27 ..... loading genome</span></span><br><span class="line"><span class="comment"># Aug 03 11:44:30 ..... started mapping</span></span><br><span class="line"><span class="comment"># Aug 03 11:44:48 ..... finished successfully</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出文件</span></span><br><span class="line"></span><br><span class="line">ls -sh trt_N061011/*</span><br><span class="line"></span><br><span class="line"><span class="comment"># trt_N061011.Aligned.out.bam: 比对到基因组的bam文件</span></span><br><span class="line"><span class="comment"># trt_N061011.Aligned.toTranscriptome.out.bam：比对到转录组的bam文件，供RSEM计算TPM使用 </span></span><br><span class="line"><span class="comment"># trt_N061011.Log.final.out: reads比对日志</span></span><br><span class="line"><span class="comment"># trt_N061011.Log.out: 运行参数和过程</span></span><br><span class="line"><span class="comment"># trt_N061011.Log.progress.out: 运行日志</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># trt_N061011.ReadsPerGene.out.tab: 每个基因的reads count，链非特异性RNASeq选第2列.</span></span><br><span class="line"><span class="comment"># column 1: gene ID</span></span><br><span class="line"><span class="comment"># column 2: counts for unstranded RNA-seq</span></span><br><span class="line"><span class="comment"># column 3: counts for the 1st read strand aligned with RNA (htseq-count option -s yes)</span></span><br><span class="line"><span class="comment"># column 4: counts for the 2nd read strand aligned with RNA (htseq-count option -s reverse)</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># Select the output according to the strandedness of your data. Note, that if you have stranded data and choose one of the columns 3 or 4, the other column (4 or 3) will give you the count of antisense reads. </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># trt_N061011.SJ.out.tab: Junction reads</span></span><br><span class="line"><span class="comment"># trt_N061011.Unmapped.out.mate1：未比对上的reads</span></span><br><span class="line"><span class="comment"># trt_N061011.Unmapped.out.mate2：未比对上的reads</span></span><br></pre></td></tr></table></figure>
<h3 id="kallisto和pseudo-alignment">Kallisto和Pseudo-Alignment</h3>
<p><code>STAR</code>是序列比对工具，而<code>Kallisto</code>是伪比对工具。它们的区别是：比对工具是把reads比对回参考基因组或转录组，而伪比对工具是把<code>k-mers</code>比对到参考转录组。</p>
<h4 id="什么是k-mer">什么是k-mer</h4>
<p><code>k-mer</code>是来源于测序短序列中的长度为<code>k</code>的子序列。例如，假设有短序列<code>ATCCCGGGTTAT</code>，想从中获得<code>7-mer</code>。为此，我们将提取前七个碱基作为第一个<code>7-mer</code>，然后向下移动一个碱基获得第二个<code>7-mer</code>，以此类推。</p>
<h4 id="为什么比对k-mers而不是reads">为什么比对k-mers而不是reads</h4>
<ol type="1">
<li>伪比对工具利用算法技巧使得比对<code>k-mers</code>比比对<code>reads</code>速度快很多<br />
</li>
<li>在某些情况下，伪对齐工具可能比传统比对工具更好的处理测序错误问题。例如，假设序列上第一个碱基中存在测序错误，本来是<code>T</code>却测序成了<code>A</code>。对伪比对工具来说，只会影响第一个<code>7-mer</code>而不会影响后续<code>7-mer</code>的比对。</li>
</ol>
<h4 id="kallisto的伪比对模式">Kallisto的伪比对模式</h4>
<p>Kallisto有一个为单细胞转录组特别设计的伪比对模式。和<code>STAR</code>不同，Kallisto比对到的是参考转录组而不是参考基因组，意味着<code>Kallisto</code>是将序列比对到剪接异构体而不是基因上，对单细胞来讲，这是有挑战性的：</p>
<ul>
<li>单细胞RNA-seq的覆盖率低于<code>bulk RNA-seq</code>，这意味着可以从序列中获得的信息总量减少了。</li>
<li>许多单细胞RNA-seq方案具有<code>3'</code>覆盖偏好性，如果两种剪接异构体只在5’末端不同，则很难确定序列来源于哪个剪接异构体。</li>
<li>一些单细胞RNA-seq方案测序读长短，也难以区分来源于哪个剪接异构体。</li>
</ul>
<p>Kallisto的伪模式采用了略微不同的伪比对方法。它不与剪接异构体比对，而是与等价类 (<code>equivalence classes</code>)比对。所以如果read比对到多个异构体，Kallisto会记录read比对到包含有所有异构体的等价类，因此可以使用等价类计数而非基因或转录本计数用于下游的聚类等分析。具体见下图：</p>
<p><img src="/images/lab2/642.webp" /></p>
<p>今天我们只用一个细胞来展示伪比对，但是Kallisto其实可以同时对大量细胞进行伪比对，并且可以使用<code>UMIs</code>的信息。</p>
<p>类似于<code>STAR</code>，伪比对前也需要为<code>Kallisto</code>生成一个索引。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir results/Kallisto</span><br><span class="line">kallisto pseudo -i indices/Kallisto/transcripts.idx -o results/Kallisto -b batch.txt</span><br></pre></td></tr></table></figure>
<p>参考 https://pachterlab.github.io/kallisto/manual 构建<code>batch.txt</code>。</p>
<p><code>batch.txt</code>文件格式如下：第一列是细胞的名字<code>ID</code>, 后面两列是对应的<code>PE reads</code>。所有<code>#</code>开头的行都忽略。如果是单端测序，命令行参数指定为<code>--single -l -s</code>，<code>batch.txt</code>只需提供一个<code>fastq</code>文件。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#id file1 file 2</span></span><br><span class="line">cell1 cell1_1.fastq.gz cell1_2.fastq.gz</span><br><span class="line">cell2 cell2_1.fastq.gz cell2_2.fastq.gz</span><br><span class="line">cell3 cell3_1.fastq.gz cell3_2.fastq.gz</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>如果使用了<code>--umi</code>参数，<code>batch.txt</code>文件格式如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#id umi-file file-1</span></span><br><span class="line">cell1 cell_1.umi cell_1.fastq.gz</span><br><span class="line">cell2 cell_2.umi cell_2.fastq.gz</span><br><span class="line">cell3 cell_3.umi cell_3.fastq.gz</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p><code>umi-file</code>是文本文件，每行是一个read的<code>UMI</code>序列，必须与<code>fastq</code>中<code>reads</code>的顺序一致。即便<code>UMI</code>数据是单端，也不会用到测序片段的长度信息。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TTACACTGAC</span><br><span class="line">CCACTCTATG</span><br><span class="line">CAGGAAATCG</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p><code>kallisto</code>在<code>UMI</code>模式下，不是计算每个<code>equivalence class</code>的<code>reads count</code>，而是使用测序reads做<code>pseudoalign</code>获得<code>equivalence class</code>, 计算每个<code>equivalence class</code>上的UMIs个数。</p>
<h4 id="理解kallisto的输出结果">理解Kallisto的输出结果</h4>
<p>上面命令会生成4个文件-<code>matrix.cells</code>, <code>matrix.ec</code>, <code>matrix.tsv</code> 和 <code>run_info.json</code>.</p>
<ul>
<li><code>matrix.cell</code> 为细胞ID列表，测试数据只用了一个细胞，这个文件应该只包含“ERR522959”</li>
<li><code>matrix.ec</code> 含有所有用到的等价类信息。每一行的第一个数字是等价类<code>ID</code>，第二个数字对应等价类的转录文本<code>ID</code>。举个例子，<code>10 1,2,3</code>表示等价类<code>10</code>包含转录文本ID <code>1</code>, <code>2</code>和<code>3</code>。ID号对应于转录本在<code>reference.transcripts.fa</code>中出现的顺序。第一个出现的转录本ID为<code>0</code>，转录本ID <code>1</code>, <code>2</code>和<code>3</code>对应于<code>reference.transcripts.fa</code>中的第二，第三和第四条转录本。</li>
<li><code>matrix.tsv</code> 表示每个等价类在不同细胞中的<code>reads count</code>信息。第一个数字是等价类ID，和<code>matrix.ec</code>中的定义一样。第二个数字是<code>细胞ID</code>，和<code>matrix.cell</code>文件中的细胞名字顺序一一对应。第三个数字是等价类在该细胞中的<code>reads count</code>。举个例子，<code>5 1 3</code>指细胞<code>1</code>中有<code>3</code>个reads比对到等价类<code>5</code>。细胞ID同样是<strong>零</strong>起始的索引，所以细胞<code>1</code>指<code>matrix.cells</code>中的第二个细胞。</li>
<li><code>run_info.json</code> 含有关于<code>Kallisto</code>执行的信息，一般可忽略。</li>
</ul>

      </div>
      
        <div class="prev-or-next">
          <div class="post-foot-next">
            
              <a href="/2020/09/23/goplot/" target="_self">
                <i class="iconfont icon-chevronleft"></i>
                <span>上一页</span>
              </a>
            
          </div>
          <div class="post-attach">
            <span class="post-pubtime">
              <i class="iconfont icon-updatetime" title="更新时间"></i>
              2020-09-23
            </span>
            
                  <span class="post-tags">
                    <i class="iconfont icon-tags" title="标签"></i>
                    
                    <span class="span--tag">
                      <a href="/tags/SingleCell/" title="SingleCell">
                        <b>#</b> SingleCell
                      </a>
                    </span>
                    
                  </span>
              
          </div>
          <div class="post-foot-prev">
            
              <a href="/2020/09/23/ggplottheme/" target="_self">
                <span>下一页</span>
                <i class="iconfont icon-chevronright"></i>
              </a>
            
          </div>
        </div>
      
    </div>
    
  <div class="post-catalog" id="catalog">
    <div class="title">目录</div>
    <div class="catalog-content">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#scrna-seq%E5%8E%9F%E5%A7%8B%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86"><span class="toc-text">scRNA-seq原始数据处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#fastqc"><span class="toc-text">FastQC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%BB%E9%99%A4%E6%8E%A5%E5%A4%B4%E5%92%8C%E4%BD%8E%E8%B4%A8%E9%87%8F%E7%A2%B1%E5%9F%BA"><span class="toc-text">移除接头和低质量碱基</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F"><span class="toc-text">文件格式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#fastq"><span class="toc-text">FastQ</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#bam"><span class="toc-text">BAM</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#cram"><span class="toc-text">CRAM</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%8B%E5%8A%A8%E6%9F%A5%E7%9C%8B%E6%96%87%E4%BB%B6"><span class="toc-text">手动查看文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E5%9B%A0%E7%BB%84%E5%92%8C%E5%9F%BA%E5%9B%A0%E6%B3%A8%E9%87%8Afastagtf"><span class="toc-text">基因组和基因注释（FASTA,GTF）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E5%BA%8F%E6%96%87%E5%BA%93%E6%8B%86%E5%88%86-demultiplexing"><span class="toc-text">测序文库拆分 (Demultiplexing)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%89%B4%E5%AE%9A%E5%90%AB%E6%9C%89%E7%BB%86%E8%83%9E%E7%9A%84%E6%B6%B2%E6%BB%B4%E5%BE%AE%E5%AD%94"><span class="toc-text">鉴定含有细胞的液滴&#x2F;微孔</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8star%E6%AF%94%E5%AF%B9read"><span class="toc-text">使用STAR比对read</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#kallisto%E5%92%8Cpseudo-alignment"><span class="toc-text">Kallisto和Pseudo-Alignment</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFk-mer"><span class="toc-text">什么是k-mer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%AF%94%E5%AF%B9k-mers%E8%80%8C%E4%B8%8D%E6%98%AFreads"><span class="toc-text">为什么比对k-mers而不是reads</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#kallisto%E7%9A%84%E4%BC%AA%E6%AF%94%E5%AF%B9%E6%A8%A1%E5%BC%8F"><span class="toc-text">Kallisto的伪比对模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%90%86%E8%A7%A3kallisto%E7%9A%84%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C"><span class="toc-text">理解Kallisto的输出结果</span></a></li></ol></li></ol></li></ol>
    </div>
  </div>

  
<script src="/js/catalog.js"></script>




    
      <div class="comments-container">
        


  <script src='//unpkg.com/valine/dist/Valine.min.js'></script>

  <div id="vcomments"></div>

  <script>
    new Valine({
      el: '#vcomments',
      appId: 'DdMocNMQxnEQcChwW38b0JVQ-gzGzoHsz',
      appKey: 'ETFXPtdWGEvlSfsH7RwSMzAf',
      placeholder: 'Welcome!',
      avatar: 'retro',
      lang: 'zh-CN'
    })
  </script>

    <style>
      .comments-container .v .vempty {
        display: none!important;
      }
    </style>




      </div>
    
  </div>


        <div class="footer">
  <div class="social">
    <ul>
      
        <li>
          <a title="github" target="_blank" rel="noopener" href="https://github.com/Moonerss">
            <i class="iconfont icon-github"></i>
          </a>
        </li>
      
        <li>
          <a title="rss" href="/atom.xml">
            <i class="iconfont icon-rss"></i>
          </a>
        </li>
      
    </ul>
  </div>
  
    <div class="footer-more">
      <a target="_blank" rel="noopener" href="https://github.com/Moonerss">Copyright © mooner 2020</a>
    </div>
  
    <div class="footer-more">
      <a target="_blank" rel="noopener" href="https://github.com/zchengsite/hexo-theme-oranges">Theme by Oranges | Powered by Hexo</a>
    </div>
  
</div>

      </div>

      <div class="back-to-top hidden">
  <a href="javascript: void(0)">
    <i class="iconfont icon-chevronup"></i>
  </a>
</div>


<script src="/js/backtotop.js"></script>



      
  <div class="search-icon" id="search-icon">
    <a href="javascript: void(0)">
      <i class="iconfont icon-search"></i>
    </a>
  </div>

  <div class="search-overlay hidden">
    <div class="search-content" tabindex="0">
      <div class="search-title">
        <span class="search-icon-input">
          <a href="javascript: void(0)">
            <i class="iconfont icon-search"></i>
          </a>
        </span>
        
          <input type="text" class="search-input" id="search-input" placeholder="Search ...">
        
        <span class="search-close-icon" id="search-close-icon">
          <a href="javascript: void(0)">
            <i class="iconfont icon-close"></i>
          </a>
        </span>
      </div>
      <div class="search-result" id="search-result"></div>
    </div>
  </div>

  <script type="text/javascript">
    var inputArea = document.querySelector("#search-input")
    var searchOverlayArea = document.querySelector(".search-overlay")

    inputArea.onclick = function() {
      getSearchFile()
      this.onclick = null
    }

    inputArea.onkeydown = function() {
      if(event.keyCode == 13)
        return false
    }

    function openOrHideSearchContent() {
      let isHidden = searchOverlayArea.classList.contains('hidden')
      if (isHidden) {
        searchOverlayArea.classList.remove('hidden')
        document.body.classList.add('hidden')
        // inputArea.focus()
      } else {
        searchOverlayArea.classList.add('hidden')
        document.body.classList.remove('hidden')
      }
    }

    function blurSearchContent(e) {
      if (e.target === searchOverlayArea) {
        openOrHideSearchContent()
      }
    }

    document.querySelector("#search-icon").addEventListener("click", openOrHideSearchContent, false)
    document.querySelector("#search-close-icon").addEventListener("click", openOrHideSearchContent, false)
    searchOverlayArea.addEventListener("click", blurSearchContent, false)

    var searchFunc = function (path, search_id, content_id) {
      'use strict';
      var $input = document.getElementById(search_id);
      var $resultContent = document.getElementById(content_id);
      $resultContent.innerHTML = "<ul><span class='local-search-empty'>首次搜索，正在载入索引文件，请稍后……<span></ul>";
      $.ajax({
        // 0x01. load xml file
        url: path,
        dataType: "xml",
        success: function (xmlResponse) {
          // 0x02. parse xml file
          var datas = $("entry", xmlResponse).map(function () {
            return {
              title: $("title", this).text(),
              content: $("content", this).text(),
              url: $("url", this).text()
            };
          }).get();
          $resultContent.innerHTML = "";

          $input.addEventListener('input', function () {
            // 0x03. parse query to keywords list
            var str = '<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length <= 0) {
              return;
            }
            // 0x04. perform local searching
            datas.forEach(function (data) {
              var isMatch = true;
              var content_index = [];
              if (!data.title || data.title.trim() === '') {
                data.title = "Untitled";
              }
              var orig_data_title = data.title.trim();
              var data_title = orig_data_title.toLowerCase();
              var orig_data_content = data.content.trim().replace(/<[^>]+>/g, "");
              var data_content = orig_data_content.toLowerCase();
              var data_url = data.url;
              var index_title = -1;
              var index_content = -1;
              var first_occur = -1;
              // only match artiles with not empty contents
              if (data_content !== '') {
                keywords.forEach(function (keyword, i) {
                  index_title = data_title.indexOf(keyword);
                  index_content = data_content.indexOf(keyword);

                  if (index_title < 0 && index_content < 0) {
                    isMatch = false;
                  } else {
                    if (index_content < 0) {
                      index_content = 0;
                    }
                    if (i == 0) {
                      first_occur = index_content;
                    }
                    // content_index.push({index_content:index_content, keyword_len:keyword_len});
                  }
                });
              } else {
                isMatch = false;
              }
              // 0x05. show search results
              if (isMatch) {
                str += "<li><a href='" + data_url + "' class='search-result-title'>" + orig_data_title + "</a>";
                var content = orig_data_content;
                if (first_occur >= 0) {
                  // cut out 100 characters
                  var start = first_occur - 20;
                  var end = first_occur + 80;

                  if (start < 0) {
                    start = 0;
                  }

                  if (start == 0) {
                    end = 100;
                  }

                  if (end > content.length) {
                    end = content.length;
                  }

                  var match_content = content.substr(start, end);

                  // highlight all keywords
                  keywords.forEach(function (keyword) {
                    var regS = new RegExp(keyword, "gi");
                    match_content = match_content.replace(regS, "<span class=\"search-keyword\">" + keyword + "</span>");
                  });

                  str += "<p class=\"search-result-abstract\">" + match_content + "...</p>"
                }
                str += "</li>";
              }
            });
            str += "</ul>";
            if (str.indexOf('<li>') === -1) {
              return $resultContent.innerHTML = "<ul><span class='local-search-empty'>没有找到内容，请尝试更换检索词。<span></ul>";
            }
            $resultContent.innerHTML = str;
          });
        },
        error: function(xhr, status, error) {
          $resultContent.innerHTML = ""
          if (xhr.status === 404) {
            $resultContent.innerHTML = "<ul><span class='local-search-empty'>未找到search.xml文件，具体请参考：<a href='https://github.com/zchengsite/hexo-theme-oranges#configuration' target='_black'>configuration</a><span></ul>";
          } else {
            $resultContent.innerHTML = "<ul><span class='local-search-empty'>请求失败，尝试重新刷新页面或稍后重试。<span></ul>";
          }
        }
      });
      $(document).on('click', '#search-close-icon', function() {
        $('#search-input').val('');
        $('#search-result').html('');
      });
    }

    var getSearchFile = function() {
        var path = "/search.xml";
        searchFunc(path, 'search-input', 'search-result');
    }
  </script>




    </div>
  </body>
</html>
